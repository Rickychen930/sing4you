name: Deploy Full Stack App to VPS

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Setup SSH
        run: |
          # Validate required secrets
          if [ -z "${{ secrets.TARGET_DIR }}" ]; then
            echo "‚ùå ERROR: TARGET_DIR secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.BACKEND_TARGET_DIR }}" ]; then
            echo "‚ùå ERROR: BACKEND_TARGET_DIR secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERROR: SSH_PRIVATE_KEY secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå ERROR: SERVER_HOST secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            echo "‚ùå ERROR: SERVER_USER secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PORT }}" ]; then
            echo "‚ùå ERROR: SSH_PORT secret is not set!"
            exit 1
          fi
          
          echo "üîß Setting up SSH..."
          echo "Host: ${{ secrets.SERVER_HOST }}"
          echo "User: ${{ secrets.SERVER_USER }}"
          echo "Port: ${{ secrets.SSH_PORT }}"
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key with proper formatting
          # Store secret in variable first to preserve all newlines
          SSH_KEY="${{ secrets.SSH_PRIVATE_KEY }}"
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Ensure file ends with newline (SSH requires this)
          if [ -s ~/.ssh/deploy_key ] && [ "$(tail -c 1 ~/.ssh/deploy_key | wc -l)" -eq 0 ]; then
            echo "" >> ~/.ssh/deploy_key
          fi
          
          # Verify key format and structure
          echo "üîç Verifying SSH key format..."
          KEY_FILE=~/.ssh/deploy_key
          
          if [ ! -f "$KEY_FILE" ]; then
            echo "‚ùå ERROR: SSH key file was not created!"
            exit 1
          fi
          
          # Check for BEGIN marker
          if ! grep -q "BEGIN.*PRIVATE KEY" "$KEY_FILE"; then
            echo "‚ùå ERROR: SSH key is missing BEGIN marker!"
            echo "First 100 chars: $(head -c 100 "$KEY_FILE")"
            exit 1
          fi
          
          # Check for END marker
          if ! grep -q "END.*PRIVATE KEY" "$KEY_FILE"; then
            echo "‚ùå ERROR: SSH key is missing END marker!"
            echo "Last 100 chars: $(tail -c 100 "$KEY_FILE")"
            exit 1
          fi
          
          # Check key file size (should be reasonable, not empty or too small)
          KEY_SIZE=$(wc -c < "$KEY_FILE")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå ERROR: SSH key file is too small ($KEY_SIZE bytes). Key may be corrupted!"
            exit 1
          fi
          
          # Validate key format with ssh-keygen
          if ssh-keygen -l -f "$KEY_FILE" > /dev/null 2>&1; then
            echo "‚úÖ SSH key format is valid"
            ssh-keygen -l -f "$KEY_FILE"
          else
            echo "‚ö†Ô∏è  WARNING: ssh-keygen validation failed, but continuing..."
            echo "Key may need passphrase or may be in different format"
          fi
          
          # Add server to known_hosts
          echo "üîë Adding server to known_hosts..."
          ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts
          
          # Setup SSH agent and add key
          echo "üîê Setting up SSH agent..."
          eval $(ssh-agent -s)
          ssh-add ~/.ssh/deploy_key 2>&1 || {
            echo "‚ö†Ô∏è  WARNING: Failed to add key to ssh-agent (may need passphrase)"
          }
          
          echo "‚úÖ SSH key configured"
          echo "üß™ Testing SSH connection..."
          
          # Test connection with detailed output
          ssh -v -o StrictHostKeyChecking=no \
              -o ConnectTimeout=10 \
              -p ${{ secrets.SSH_PORT }} \
              ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
              "echo '‚úÖ SSH connection successful'" 2>&1 || {
            echo "‚ùå SSH connection test failed!"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify public key is in ~/.ssh/authorized_keys on server"
            echo "2. Check username: ${{ secrets.SERVER_USER }}"
            echo "3. Check host: ${{ secrets.SERVER_HOST }}"
            echo "4. Check port: ${{ secrets.SSH_PORT }}"
            echo "5. Verify SSH_PRIVATE_KEY format in GitHub Secrets"
            echo ""
            echo "To add public key to server, run on server:"
            echo "  mkdir -p ~/.ssh && chmod 700 ~/.ssh"
            echo "  echo 'PUBLIC_KEY_HERE' >> ~/.ssh/authorized_keys"
            echo "  chmod 600 ~/.ssh/authorized_keys"
            exit 1
          }

      # ‚úÖ Build Frontend
      - name: Create .env.production for frontend
        run: |
          echo "REACT_APP_API_URL=${{ secrets.REACT_APP_API_URL }}" > .env.production

      - name: Build React app
        run: npm run build

      # ‚úÖ Build Backend
      - name: Build backend server
        run: npm run build:server

      # ‚úÖ Prepare directories on VPS
      - name: Prepare VPS directories
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 10m
          use_insecure_cipher: false
          debug: true
          script: |
            set -e
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            RELEASES="$FRONTEND_TARGET/_releases"
            TS="$(date +%Y%m%d-%H%M%S)"
            NEW="$RELEASES/$TS"

            # Create parent directories first
            mkdir -p "$(dirname "$FRONTEND_TARGET")" 2>/dev/null || true
            mkdir -p "$(dirname "$BACKEND_TARGET")" 2>/dev/null || true
            
            # Frontend directories with explicit permissions
            echo "Creating frontend directories..."
            mkdir -p "$FRONTEND_TARGET"
            mkdir -p "$RELEASES"
            mkdir -p "$NEW"
            mkdir -p "$FRONTEND_TARGET/_incoming"
            chmod -R 755 "$FRONTEND_TARGET" || true
            chmod 777 "$FRONTEND_TARGET/_incoming" || true
            # Try to set ownership (may fail if not root, that's ok)
            chown -R "$(whoami):$(whoami)" "$FRONTEND_TARGET" 2>/dev/null || true

            # Backend directories with explicit permissions
            echo "Creating backend directories..."
            mkdir -p "$BACKEND_TARGET"
            mkdir -p "$BACKEND_TARGET/dist"
            mkdir -p "$BACKEND_TARGET/server"
            mkdir -p "$BACKEND_TARGET/uploads"
            mkdir -p "$BACKEND_TARGET/_incoming_backend"
            chmod -R 755 "$BACKEND_TARGET" || true
            chmod 777 "$BACKEND_TARGET/_incoming_backend" || true
            # Try to set ownership (may fail if not root, that's ok)
            chown -R "$(whoami):$(whoami)" "$BACKEND_TARGET" 2>/dev/null || true

            # Verify directories are writable
            if [ ! -w "$FRONTEND_TARGET/_incoming" ]; then
              echo "‚ö†Ô∏è  Warning: $FRONTEND_TARGET/_incoming may not be writable"
              ls -ld "$FRONTEND_TARGET/_incoming" || true
            fi
            
            if [ ! -w "$BACKEND_TARGET/_incoming_backend" ]; then
              echo "‚ö†Ô∏è  Warning: $BACKEND_TARGET/_incoming_backend may not be writable"
              ls -ld "$BACKEND_TARGET/_incoming_backend" || true
            fi

            echo "‚úÖ Frontend release dir: $NEW"
            echo "‚úÖ Backend target: $BACKEND_TARGET"
            echo "‚úÖ All directories created"

      # ‚úÖ Upload Frontend build (using SCP like the working workflow)
      - name: Upload frontend build to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 20m
          use_insecure_cipher: false
          source: "build/**"
          target: "${{ secrets.TARGET_DIR }}/_incoming"
          overwrite: true

      # ‚úÖ Ensure backend directories exist before upload
      - name: Ensure backend upload directories exist
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            
            if [ -z "$BACKEND_TARGET" ]; then
              echo "‚ùå ERROR: BACKEND_TARGET_DIR secret is not set!"
              echo "Please configure BACKEND_TARGET_DIR in GitHub Secrets"
              exit 1
            fi
            
            echo "Creating directories at: $BACKEND_TARGET"
            mkdir -p "$BACKEND_TARGET/_incoming_backend"
            mkdir -p "$BACKEND_TARGET"
            chmod -R 755 "$BACKEND_TARGET" || true
            echo "‚úÖ Backend directories ready"

      # ‚úÖ Upload Backend dist (using SCP like the working workflow)
      - name: Upload backend dist to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 20m
          use_insecure_cipher: false
          source: "dist/**"
          target: "${{ secrets.BACKEND_TARGET_DIR }}/_incoming_backend"
          overwrite: true

      # ‚úÖ Upload package.json and package-lock.json for dependency installation
      - name: Upload package files for dependency installation
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "package.json,package-lock.json"
          target: "${{ secrets.BACKEND_TARGET_DIR }}"
          overwrite: true

      - name: Upload ecosystem.config.js via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            mkdir -p "$BACKEND_TARGET"
            cat > "$BACKEND_TARGET/ecosystem.config.js" << EOF
            module.exports = {
              apps: [
                {
                  name: "giftforyou-api",
                  script: "dist/server/server.js",
                  cwd: "${BACKEND_TARGET}",
                  instances: 1,
                  exec_mode: "fork",
                  env_file: "server/.env",
                  env: {
                    NODE_ENV: "production",
                    PORT: 4000,
                  },
                  error_file: "./logs/pm2-error.log",
                  out_file: "./logs/pm2-out.log",
                  log_date_format: "YYYY-MM-DD HH:mm:ss Z",
                  merge_logs: true,
                  autorestart: true,
                  max_restarts: 10,
                  min_uptime: "10s",
                  max_memory_restart: "500M",
                  watch: false,
                  ignore_watch: ["node_modules", "logs", "uploads"],
                },
              ],
            };
            EOF
            chmod 644 "$BACKEND_TARGET/ecosystem.config.js"
            echo "‚úÖ ecosystem.config.js uploaded with cwd: ${BACKEND_TARGET}"

      # ‚úÖ Activate Frontend Release
      - name: Activate frontend release (atomic)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 10m
          use_insecure_cipher: false
          script: |
            set -e
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            RELEASES="$FRONTEND_TARGET/_releases"
            INCOMING="$FRONTEND_TARGET/_incoming/build"
            TS="$(date +%Y%m%d-%H%M%S)"
            NEW="$RELEASES/$TS"
            CURRENT="$FRONTEND_TARGET/current"
            BUILD_ROOT="$FRONTEND_TARGET/build"

            if [ ! -d "$INCOMING" ]; then
              echo "ERROR: Incoming frontend build not found at $INCOMING"
              ls -la "$FRONTEND_TARGET/_incoming" || true
              exit 1
            fi

            mkdir -p "$NEW"
            cp -a "$INCOMING"/. "$NEW"/

            # atomic switch
            rm -f "$CURRENT"
            ln -s "$NEW" "$CURRENT"

            # Keep nginx root in sync
            if [ -e "$BUILD_ROOT" ] || [ -L "$BUILD_ROOT" ]; then
              rm -rf "$BUILD_ROOT"
            fi
            ln -s "$NEW" "$BUILD_ROOT"

            chmod -R 755 "$NEW"
            rm -rf "$FRONTEND_TARGET/_incoming"

            echo "‚úÖ Frontend activated"
            echo "Current -> $(readlink $CURRENT)"
            echo "BuildRoot -> $(readlink $BUILD_ROOT)"

      # ‚úÖ Deploy Backend
      - name: Deploy backend and restart PM2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 15m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist"
            DIST_DIR="$BACKEND_TARGET/dist"

            # Handle different upload structures
            if [ -d "$BACKEND_TARGET/_incoming_backend/dist/dist" ]; then
              # If nested dist/dist structure
              INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist/dist"
            elif [ -d "$BACKEND_TARGET/_incoming_backend/dist" ]; then
              # Normal structure
              INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist"
            else
              # Check if dist is directly in _incoming_backend
              if [ -d "$BACKEND_TARGET/_incoming_backend/server" ] || [ -f "$BACKEND_TARGET/_incoming_backend/server/server.js" ]; then
                INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend"
              fi
            fi
            ENV_FILE="$BACKEND_TARGET/server/.env"
            ENV_PROD_FILE="$BACKEND_TARGET/.env.production"

            echo "=== Backend Deployment ==="

            # Check if incoming backend exists
            if [ ! -d "$INCOMING_BACKEND" ]; then
              echo "ERROR: Incoming backend dist not found at $INCOMING_BACKEND"
              ls -la "$BACKEND_TARGET/_incoming_backend" || true
              exit 1
            fi

            # Backup current dist (optional, for rollback)
            if [ -d "$DIST_DIR" ]; then
              echo "Backing up current dist..."
              BACKUP_DIR="$BACKEND_TARGET/dist.backup.$(date +%Y%m%d-%H%M%S)"
              cp -a "$DIST_DIR" "$BACKUP_DIR" || true
              echo "Backup created at: $BACKUP_DIR"
            fi

            # Remove old dist and copy new one
            echo "Deploying new backend dist..."
            rm -rf "$DIST_DIR"
            mkdir -p "$DIST_DIR"
            cp -a "$INCOMING_BACKEND"/. "$DIST_DIR"/

            # Ensure .env file exists (create from secrets if needed, or keep existing)
            if [ ! -f "$ENV_FILE" ] && [ -f "$ENV_PROD_FILE" ]; then
              echo "Copying .env.production to server/.env..."
              mkdir -p "$BACKEND_TARGET/server"
              cp "$ENV_PROD_FILE" "$ENV_FILE"
            fi

            # Verify critical files
            if [ ! -f "$DIST_DIR/server/server.js" ]; then
              echo "ERROR: server.js not found in dist!"
              exit 1
            fi

            echo "‚úÖ Backend files deployed"

            # Install dependencies if package.json exists
            echo "=== Installing Dependencies ==="
            if [ -f "$BACKEND_TARGET/package.json" ]; then
              echo "package.json found, installing dependencies..."
              cd "$BACKEND_TARGET"
              npm install --production
              if [ $? -eq 0 ]; then
                echo "‚úÖ Dependencies installed successfully"
              else
                echo "‚ö†Ô∏è  Warning: npm install failed, but continuing..."
              fi
            else
              echo "‚ö†Ô∏è  Warning: package.json not found, skipping dependency installation"
              echo "‚ö†Ô∏è  You may need to install dependencies manually"
            fi

            # Stop old PM2 process if running
            echo "=== PM2 Management ==="
            pm2 stop giftforyou-api || true
            pm2 delete giftforyou-api || true

            # Kill any process on port 4000 (safety measure)
            echo "Checking for processes on port 4000..."
            PORT_PID=$(lsof -ti:4000 || true)
            if [ ! -z "$PORT_PID" ]; then
              echo "Killing process $PORT_PID on port 4000..."
              kill -9 $PORT_PID || true
              sleep 2
            fi

            # Start PM2 with proper environment
            echo "Starting PM2 process..."
            cd "$BACKEND_TARGET"

            # Use ecosystem.config.js if exists, otherwise start directly
            if [ -f "ecosystem.config.js" ]; then
              pm2 start ecosystem.config.js
            elif [ -f "server/.env" ]; then
              pm2 start dist/server/server.js \
                --name giftforyou-api \
                --env-file server/.env \
                --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                --merge-logs
            elif [ -f ".env.production" ]; then
              pm2 start dist/server/server.js \
                --name giftforyou-api \
                --env-file .env.production \
                --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                --merge-logs
            else
              # Fallback: start without env-file (assumes env vars are set in system)
              pm2 start dist/server/server.js \
                --name giftforyou-api \
                --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                --merge-logs
            fi

            # Save PM2 configuration
            pm2 save

            # Cleanup incoming backend
            rm -rf "$BACKEND_TARGET/_incoming_backend"

            echo "‚úÖ Backend deployment complete"

      # ‚úÖ Verify Deployment
      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          script: |
            set -e
            echo "=== Verification ==="

            # Check PM2 status
            echo "PM2 Status:"
            pm2 status || true
            pm2 logs giftforyou-api --lines 20 --nostream || true

            # Check backend health
            echo -e "\nBackend Health Check:"
            sleep 3
            curl -f http://localhost:4000/api/health || echo "‚ö†Ô∏è Health check failed (may need more time)"

            # Check frontend
            echo -e "\nFrontend Check:"
            if [ -L "${{ secrets.TARGET_DIR }}/current" ]; then
              echo "‚úÖ Frontend symlink exists"
              ls -la "${{ secrets.TARGET_DIR }}/current" | head -5
            else
              echo "‚ö†Ô∏è Frontend symlink not found"
            fi

            echo -e "\n‚úÖ Deployment verification complete"
