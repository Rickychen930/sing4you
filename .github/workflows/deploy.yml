name: Deploy Full Stack App to VPS

on:
  push:
    branches: [main, master]
  workflow_dispatch:  # Allow manual trigger from GitHub Actions UI

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Setup SSH
        run: |
          # ============================================================================
          # SSH Configuration
          # ============================================================================
          # Required GitHub Secrets:
          # - SERVER_HOST: IP address (e.g., 76.13.96.198)
          # - SERVER_USER: SSH username (e.g., root)
          # - SSH_PORT: SSH port (e.g., 22)
          # - SSH_PRIVATE_KEY: Complete private key including BEGIN/END lines
          # - TARGET_DIR: Frontend deployment directory
          # - BACKEND_TARGET_DIR: Backend deployment directory
          # ============================================================================
          
          # Validate required secrets
          if [ -z "${{ secrets.TARGET_DIR }}" ]; then
            echo "‚ùå ERROR: TARGET_DIR secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.BACKEND_TARGET_DIR }}" ]; then
            echo "‚ùå ERROR: BACKEND_TARGET_DIR secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERROR: SSH_PRIVATE_KEY secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå ERROR: SERVER_HOST secret is not set!"
            echo "   Expected: 76.13.96.198"
            exit 1
          fi
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            echo "‚ùå ERROR: SERVER_USER secret is not set!"
            echo "   Expected: root"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PORT }}" ]; then
            echo "‚ùå ERROR: SSH_PORT secret is not set!"
            echo "   Expected: 22 (or your SSH port)"
            exit 1
          fi
          
          echo "üîß Setting up SSH..."
          echo "Host: ${{ secrets.SERVER_HOST }}"
          echo "User: ${{ secrets.SERVER_USER }}"
          echo "Port: ${{ secrets.SSH_PORT }}"
          echo ""
          echo "üìù Note: SSH connection will be: ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}"
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key with proper formatting
          # Store secret in variable first to preserve all newlines
          SSH_KEY="${{ secrets.SSH_PRIVATE_KEY }}"
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Ensure file ends with newline (SSH requires this)
          if [ -s ~/.ssh/deploy_key ] && [ "$(tail -c 1 ~/.ssh/deploy_key | wc -l)" -eq 0 ]; then
            echo "" >> ~/.ssh/deploy_key
          fi
          
          # Verify key format and structure
          echo "üîç Verifying SSH key format..."
          KEY_FILE=~/.ssh/deploy_key
          
          if [ ! -f "$KEY_FILE" ]; then
            echo "‚ùå ERROR: SSH key file was not created!"
            exit 1
          fi
          
          # Check for BEGIN marker
          if ! grep -q "BEGIN.*PRIVATE KEY" "$KEY_FILE"; then
            echo "‚ùå ERROR: SSH key is missing BEGIN marker!"
            echo "First 100 chars: $(head -c 100 "$KEY_FILE")"
            exit 1
          fi
          
          # Check for END marker
          if ! grep -q "END.*PRIVATE KEY" "$KEY_FILE"; then
            echo "‚ùå ERROR: SSH key is missing END marker!"
            echo "Last 100 chars: $(tail -c 100 "$KEY_FILE")"
            exit 1
          fi
          
          # Check key file size (should be reasonable, not empty or too small)
          KEY_SIZE=$(wc -c < "$KEY_FILE")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå ERROR: SSH key file is too small ($KEY_SIZE bytes). Key may be corrupted!"
            exit 1
          fi
          
          # Validate key format with ssh-keygen
          if ssh-keygen -l -f "$KEY_FILE" > /dev/null 2>&1; then
            echo "‚úÖ SSH key format is valid"
            ssh-keygen -l -f "$KEY_FILE"
          else
            echo "‚ö†Ô∏è  WARNING: ssh-keygen validation failed, but continuing..."
            echo "Key may need passphrase or may be in different format"
          fi
          
          # Add server to known_hosts
          echo "üîë Adding server to known_hosts..."
          ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts
          
          # Setup SSH agent and add key
          echo "üîê Setting up SSH agent..."
          eval $(ssh-agent -s)
          ssh-add ~/.ssh/deploy_key 2>&1 || {
            echo "‚ö†Ô∏è  WARNING: Failed to add key to ssh-agent (may need passphrase)"
          }
          
          echo "‚úÖ SSH key configured"
          
          # Verify key file exists and has correct permissions
          if [ ! -f ~/.ssh/deploy_key ]; then
            echo "‚ùå ERROR: SSH key file not found at ~/.ssh/deploy_key"
            exit 1
          fi
          
          # Show key fingerprint for debugging
          echo "üîë SSH Key Fingerprint:"
          ssh-keygen -l -f ~/.ssh/deploy_key 2>&1 || echo "‚ö†Ô∏è  Could not get fingerprint"
          
          # Extract and show public key (for troubleshooting)
          echo ""
          echo "üìã Public Key (to add to server's ~/.ssh/authorized_keys if needed):"
          ssh-keygen -y -f ~/.ssh/deploy_key 2>&1 | head -1 || echo "‚ö†Ô∏è  Could not extract public key"
          echo ""
          
          # Test basic connectivity first
          echo "üåê Testing basic connectivity..."
          echo "Host: ${{ secrets.SERVER_HOST }}"
          echo "Port: ${{ secrets.SSH_PORT }}"
          echo "User: ${{ secrets.SERVER_USER }}"
          echo ""
          
          # Test if host is reachable (ping-like test with timeout)
          if command -v nc >/dev/null 2>&1; then
            echo "Testing port connectivity with nc..."
            if nc -zv -w 5 ${{ secrets.SERVER_HOST }} ${{ secrets.SSH_PORT }} 2>&1; then
              echo "‚úÖ Port ${{ secrets.SSH_PORT }} is reachable"
            else
              echo "‚ùå Port ${{ secrets.SSH_PORT }} is NOT reachable"
              echo "‚ö†Ô∏è  This might be a firewall/network issue"
            fi
          fi
          
          echo ""
          echo "üß™ Testing SSH connection..."
          
          # Test connection with detailed output
          ssh -v -i ~/.ssh/deploy_key \
              -o StrictHostKeyChecking=no \
              -o IdentitiesOnly=yes \
              -o ConnectTimeout=15 \
              -o PasswordAuthentication=no \
              -o BatchMode=yes \
              -p ${{ secrets.SSH_PORT }} \
              ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
              "echo '‚úÖ SSH connection successful'" 2>&1 || {
            echo ""
            echo "‚ùå SSH connection test failed!"
            echo ""
            echo "üîç Diagnostic Information:"
            echo "  Host: ${{ secrets.SERVER_HOST }}"
            echo "  Port: ${{ secrets.SSH_PORT }}"
            echo "  User: ${{ secrets.SERVER_USER }}"
            echo ""
            echo "üìã Troubleshooting steps:"
            echo ""
            echo "1. CONNECTION TIMEOUT (if you see 'Connection timed out'):"
            echo "   ‚Üí Check if server IP is correct: ${{ secrets.SERVER_HOST }}"
            echo "   ‚Üí Check if SSH port is correct: ${{ secrets.SSH_PORT }}"
            echo "   ‚Üí Check firewall/security group allows port ${{ secrets.SSH_PORT }} from GitHub Actions"
            echo "   ‚Üí GitHub Actions IP ranges: 140.82.112.0/20, 143.55.64.0/20"
            echo "   ‚Üí Test from your local: ssh -v ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} -p ${{ secrets.SSH_PORT }}"
            echo ""
            echo "2. AUTHENTICATION FAILED (if you see 'Permission denied'):"
            echo "   ‚Üí Verify public key is in ~/.ssh/authorized_keys on server"
            echo "   ‚Üí Check username: ${{ secrets.SERVER_USER }}"
            echo "   ‚Üí Verify SSH_PRIVATE_KEY format in GitHub Secrets (must include BEGIN/END lines)"
            echo ""
            echo "3. To add public key to server, run on server:"
            echo "   mkdir -p ~/.ssh && chmod 700 ~/.ssh"
            echo "   echo 'PUBLIC_KEY_HERE' >> ~/.ssh/authorized_keys"
            echo "   chmod 600 ~/.ssh/authorized_keys"
            echo ""
            echo "4. Check server firewall (on server):"
            echo "   sudo ufw status"
            echo "   sudo ufw allow ${{ secrets.SSH_PORT }}/tcp"
            echo ""
            exit 1
          }

      # ‚úÖ Build Frontend
      - name: Create .env.production for frontend
        run: |
          echo "REACT_APP_API_URL=${{ secrets.REACT_APP_API_URL }}" > .env.production

      - name: Build React app
        run: npm run build

      # ‚úÖ Build Backend
      - name: Build backend server
        run: npm run build:server

      # ‚úÖ Prepare directories on VPS
      - name: Prepare VPS directories
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 10m
          use_insecure_cipher: false
          debug: true
          script: |
            set -e
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            RELEASES="$FRONTEND_TARGET/_releases"
            TS="$(date +%Y%m%d-%H%M%S)"
            NEW="$RELEASES/$TS"

            # Create parent directories first
            mkdir -p "$(dirname "$FRONTEND_TARGET")" 2>/dev/null || true
            mkdir -p "$(dirname "$BACKEND_TARGET")" 2>/dev/null || true
            
            # Frontend directories with explicit permissions
            echo "Creating frontend directories..."
            mkdir -p "$FRONTEND_TARGET"
            mkdir -p "$RELEASES"
            mkdir -p "$NEW"
            mkdir -p "$FRONTEND_TARGET/_incoming"
            chmod -R 755 "$FRONTEND_TARGET" || true
            chmod 777 "$FRONTEND_TARGET/_incoming" || true
            # Try to set ownership (may fail if not root, that's ok)
            chown -R "$(whoami):$(whoami)" "$FRONTEND_TARGET" 2>/dev/null || true

            # Backend directories with explicit permissions
            echo "Creating backend directories..."
            mkdir -p "$BACKEND_TARGET"
            mkdir -p "$BACKEND_TARGET/dist"
            mkdir -p "$BACKEND_TARGET/server"
            mkdir -p "$BACKEND_TARGET/uploads"
            mkdir -p "$BACKEND_TARGET/_incoming_backend"
            chmod -R 755 "$BACKEND_TARGET" || true
            chmod 777 "$BACKEND_TARGET/_incoming_backend" || true
            # Try to set ownership (may fail if not root, that's ok)
            chown -R "$(whoami):$(whoami)" "$BACKEND_TARGET" 2>/dev/null || true

            # Verify directories are writable
            if [ ! -w "$FRONTEND_TARGET/_incoming" ]; then
              echo "‚ö†Ô∏è  Warning: $FRONTEND_TARGET/_incoming may not be writable"
              ls -ld "$FRONTEND_TARGET/_incoming" || true
            fi
            
            if [ ! -w "$BACKEND_TARGET/_incoming_backend" ]; then
              echo "‚ö†Ô∏è  Warning: $BACKEND_TARGET/_incoming_backend may not be writable"
              ls -ld "$BACKEND_TARGET/_incoming_backend" || true
            fi

            echo "‚úÖ Frontend release dir: $NEW"
            echo "‚úÖ Backend target: $BACKEND_TARGET"
            echo "‚úÖ All directories created"

      # ‚úÖ Upload Frontend build (using SCP like the working workflow)
      - name: Upload frontend build to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 20m
          use_insecure_cipher: false
          source: "dist/client/**"
          target: "${{ secrets.TARGET_DIR }}/_incoming"
          overwrite: true

      # ‚úÖ Ensure backend directories exist before upload
      - name: Ensure backend upload directories exist
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            
            if [ -z "$BACKEND_TARGET" ]; then
              echo "‚ùå ERROR: BACKEND_TARGET_DIR secret is not set!"
              echo "Please configure BACKEND_TARGET_DIR in GitHub Secrets"
              exit 1
            fi
            
            echo "Creating directories at: $BACKEND_TARGET"
            mkdir -p "$BACKEND_TARGET/_incoming_backend"
            mkdir -p "$BACKEND_TARGET"
            chmod -R 755 "$BACKEND_TARGET" || true
            echo "‚úÖ Backend directories ready"

      # ‚úÖ Upload Backend dist (using SCP like the working workflow)
      - name: Upload backend dist to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 20m
          use_insecure_cipher: false
          source: "dist/**"
          target: "${{ secrets.BACKEND_TARGET_DIR }}/_incoming_backend"
          overwrite: true

      # ‚úÖ Upload package.json and package-lock.json for dependency installation
      - name: Upload package files for dependency installation
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "package.json,package-lock.json"
          target: "${{ secrets.BACKEND_TARGET_DIR }}"
          overwrite: true

      - name: Upload ecosystem.config.cjs via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            mkdir -p "$BACKEND_TARGET"
            cat > "$BACKEND_TARGET/ecosystem.config.cjs" << EOF
            module.exports = {
              apps: [
                {
                  name: "sing4you-api",
                  script: "dist/server/index.js",
                  cwd: "${BACKEND_TARGET}",
                  instances: 1,
                  exec_mode: "fork",
                  env: {
                    NODE_ENV: "production",
                    PORT: 4000,
                    BACKEND_ROOT: "${BACKEND_TARGET}",
                  },
                  error_file: "./logs/pm2-error.log",
                  out_file: "./logs/pm2-out.log",
                  log_date_format: "YYYY-MM-DD HH:mm:ss Z",
                  merge_logs: true,
                  autorestart: true,
                  max_restarts: 10,
                  min_uptime: "10s",
                  max_memory_restart: "500M",
                  watch: false,
                  ignore_watch: ["node_modules", "logs", "uploads"],
                },
              ],
            };
            EOF
            chmod 644 "$BACKEND_TARGET/ecosystem.config.cjs"
            echo "‚úÖ ecosystem.config.cjs uploaded with cwd: ${BACKEND_TARGET}"

      # ‚úÖ Activate Frontend Release
      - name: Activate frontend release (atomic)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 10m
          use_insecure_cipher: false
          script: |
            set -e
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            RELEASES="$FRONTEND_TARGET/_releases"
            INCOMING="$FRONTEND_TARGET/_incoming"
            TS="$(date +%Y%m%d-%H%M%S)"
            NEW="$RELEASES/$TS"
            CURRENT="$FRONTEND_TARGET/current"
            BUILD_ROOT="$FRONTEND_TARGET/build"

            if [ ! -d "$INCOMING" ]; then
              echo "ERROR: Incoming frontend build not found at $INCOMING"
              ls -la "$FRONTEND_TARGET/_incoming" || true
              exit 1
            fi

            mkdir -p "$NEW"
            cp -a "$INCOMING"/. "$NEW"/

            # atomic switch
            rm -f "$CURRENT"
            ln -s "$NEW" "$CURRENT"

            # Keep nginx root in sync
            if [ -e "$BUILD_ROOT" ] || [ -L "$BUILD_ROOT" ]; then
              rm -rf "$BUILD_ROOT"
            fi
            ln -s "$NEW" "$BUILD_ROOT"

            chmod -R 755 "$NEW"
            rm -rf "$FRONTEND_TARGET/_incoming"

            echo "‚úÖ Frontend activated"
            echo "Current -> $(readlink $CURRENT)"
            echo "BuildRoot -> $(readlink $BUILD_ROOT)"

      # ‚úÖ Deploy Backend
      - name: Deploy backend and restart PM2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 15m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist"
            DIST_DIR="$BACKEND_TARGET/dist"

            # Handle different upload structures
            if [ -d "$BACKEND_TARGET/_incoming_backend/dist/dist" ]; then
              # If nested dist/dist structure
              INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist/dist"
            elif [ -d "$BACKEND_TARGET/_incoming_backend/dist" ]; then
              # Normal structure
              INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist"
            else
              # Check if dist is directly in _incoming_backend
              if [ -d "$BACKEND_TARGET/_incoming_backend/server" ] || [ -f "$BACKEND_TARGET/_incoming_backend/server/server.js" ]; then
                INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend"
              fi
            fi
            ENV_FILE="$BACKEND_TARGET/server/.env"
            ENV_PROD_FILE="$BACKEND_TARGET/.env.production"

            echo "=== Backend Deployment ==="

            # Check if incoming backend exists
            if [ ! -d "$INCOMING_BACKEND" ]; then
              echo "ERROR: Incoming backend dist not found at $INCOMING_BACKEND"
              ls -la "$BACKEND_TARGET/_incoming_backend" || true
              exit 1
            fi

            # Backup current dist (optional, for rollback)
            if [ -d "$DIST_DIR" ]; then
              echo "Backing up current dist..."
              BACKUP_DIR="$BACKEND_TARGET/dist.backup.$(date +%Y%m%d-%H%M%S)"
              cp -a "$DIST_DIR" "$BACKUP_DIR" || true
              echo "Backup created at: $BACKUP_DIR"
            fi

            # Remove old dist and copy new one
            echo "Deploying new backend dist..."
            rm -rf "$DIST_DIR"
            mkdir -p "$DIST_DIR"
            cp -a "$INCOMING_BACKEND"/. "$DIST_DIR"/

            # Ensure .env file exists (create from secrets if needed, or keep existing)
            if [ ! -f "$ENV_FILE" ] && [ -f "$ENV_PROD_FILE" ]; then
              echo "Copying .env.production to server/.env..."
              mkdir -p "$BACKEND_TARGET/server"
              cp "$ENV_PROD_FILE" "$ENV_FILE"
            fi
            
            # Copy .env to root directory (app loads from root in production)
            if [ -f "$ENV_FILE" ]; then
              echo "Copying server/.env to root .env for production..."
              cp "$ENV_FILE" "$BACKEND_TARGET/.env"
            elif [ -f "$ENV_PROD_FILE" ]; then
              echo "Copying .env.production to root .env for production..."
              cp "$ENV_PROD_FILE" "$BACKEND_TARGET/.env"
            fi
            
            # Ensure PORT=4000 in .env (critical for nginx proxy)
            if [ -f "$BACKEND_TARGET/.env" ]; then
              echo "Ensuring PORT=4000 in .env..."
              if grep -q "^PORT=" "$BACKEND_TARGET/.env"; then
                sed -i 's/^PORT=.*/PORT=4000/' "$BACKEND_TARGET/.env"
              else
                echo "PORT=4000" >> "$BACKEND_TARGET/.env"
              fi
              echo "‚úÖ PORT set to 4000 in .env"
            fi

            # Verify critical files
            if [ ! -f "$DIST_DIR/server/index.js" ]; then
              echo "ERROR: index.js not found in dist!"
              exit 1
            fi

            echo "‚úÖ Backend files deployed"

            # Install dependencies if package.json exists
            echo "=== Installing Dependencies ==="
            if [ -f "$BACKEND_TARGET/package.json" ]; then
              echo "package.json found, installing dependencies..."
              cd "$BACKEND_TARGET"
              npm install --production
              if [ $? -eq 0 ]; then
                echo "‚úÖ Dependencies installed successfully"
              else
                echo "‚ö†Ô∏è  Warning: npm install failed, but continuing..."
              fi
            else
              echo "‚ö†Ô∏è  Warning: package.json not found, skipping dependency installation"
              echo "‚ö†Ô∏è  You may need to install dependencies manually"
            fi

            # Stop old PM2 process if running
            echo "=== PM2 Management ==="
            pm2 stop sing4you-api || true
            pm2 delete sing4you-api || true

            # Kill any process on port 4000 (safety measure)
            echo "Checking for processes on port 4000..."
            PORT_PID=$(lsof -ti:4000 || true)
            if [ ! -z "$PORT_PID" ]; then
              echo "Killing process $PORT_PID on port 4000..."
              kill -9 $PORT_PID || true
              sleep 2
            fi

            # Start PM2 with proper environment
            echo "Starting PM2 process..."
            cd "$BACKEND_TARGET"

            # Verify dist/server/index.js exists
            if [ ! -f "dist/server/index.js" ]; then
              echo "‚ùå ERROR: dist/server/index.js not found!"
              echo "Available files in dist/server:"
              ls -la dist/server/ || echo "dist/server directory does not exist"
              exit 1
            fi

            # Check if node_modules exists, if not, install dependencies
            if [ ! -d "node_modules" ]; then
              echo "‚ö†Ô∏è  node_modules not found, installing dependencies..."
              npm install --production || {
                echo "‚ùå ERROR: npm install failed!"
                exit 1
              }
            fi

            # Use ecosystem.config.cjs if exists, otherwise start directly
            if [ -f "ecosystem.config.cjs" ]; then
              echo "Using ecosystem.config.cjs..."
              pm2 start ecosystem.config.cjs || {
                echo "‚ùå ERROR: Failed to start PM2 with ecosystem.config.cjs"
                echo "Trying direct start..."
                mkdir -p logs
                pm2 start dist/server/index.js \
                  --name sing4you-api \
                  --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                  --merge-logs \
                  --error ./logs/pm2-error.log \
                  --output ./logs/pm2-out.log
              }
            else
              echo "‚ö†Ô∏è  ecosystem.config.cjs not found, starting directly..."
              echo "   Make sure .env file exists in root directory"
              mkdir -p logs
              pm2 start dist/server/index.js \
                --name sing4you-api \
                --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                --merge-logs \
                --error ./logs/pm2-error.log \
                --output ./logs/pm2-out.log
            fi

            # Wait a moment and check if PM2 process started successfully
            sleep 3
            if pm2 list | grep -q "sing4you-api.*online"; then
              echo "‚úÖ PM2 process started successfully"
            else
              echo "‚ö†Ô∏è  WARNING: PM2 process may not have started correctly"
              echo "PM2 status:"
              pm2 list
              echo "PM2 logs:"
              pm2 logs sing4you-api --lines 20 --nostream || true
            fi

            # Save PM2 configuration
            pm2 save

            # Cleanup incoming backend
            rm -rf "$BACKEND_TARGET/_incoming_backend"

            echo "‚úÖ Backend deployment complete"

      # ‚úÖ Deploy Nginx Configuration
      - name: Upload nginx configuration
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "deployment/nginx/christina-sings4you.com.au.conf"
          target: "/tmp"
          overwrite: true

      - name: Deploy nginx configuration to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            DOMAIN="christina-sings4you.com.au"
            NGINX_SITES_AVAILABLE="/etc/nginx/sites-available"
            NGINX_SITES_ENABLED="/etc/nginx/sites-enabled"
            NGINX_CONFIG_FILE="${NGINX_SITES_AVAILABLE}/${DOMAIN}.conf"
            TEMP_CONFIG="/tmp/christina-sings4you.com.au.conf"
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            
            echo "=== Nginx Configuration Deployment ==="
            
            # Debug: Check what files are in /tmp
            echo "Checking /tmp directory for uploaded files..."
            ls -la /tmp/ | grep -i "christina\|nginx" || true
            find /tmp -name "*christina*" -o -name "*nginx*" 2>/dev/null || true
            
            # Check if temp config exists in expected location
            if [ ! -f "$TEMP_CONFIG" ]; then
              echo "‚ö†Ô∏è  File not found at $TEMP_CONFIG, checking alternative locations..."
              # Check if it was uploaded with directory structure preserved
              if [ -f "/tmp/deployment/nginx/christina-sings4you.com.au.conf" ]; then
                echo "Found file at /tmp/deployment/nginx/christina-sings4you.com.au.conf, copying to expected location..."
                cp "/tmp/deployment/nginx/christina-sings4you.com.au.conf" "$TEMP_CONFIG"
              elif [ -f "/tmp/nginx/christina-sings4you.com.au.conf" ]; then
                echo "Found file at /tmp/nginx/christina-sings4you.com.au.conf, copying to expected location..."
                cp "/tmp/nginx/christina-sings4you.com.au.conf" "$TEMP_CONFIG"
              else
                echo "‚ùå ERROR: Nginx config file not found at $TEMP_CONFIG or alternative locations"
                echo "Contents of /tmp:"
                ls -la /tmp/ || true
                exit 1
              fi
            fi
            
            echo "‚úÖ Found nginx config file at $TEMP_CONFIG"
            
            # Backup existing config if exists
            if [ -f "$NGINX_CONFIG_FILE" ]; then
              echo "Backing up existing nginx config..."
              BACKUP_FILE="${NGINX_CONFIG_FILE}.backup.$(date +%Y%m%d-%H%M%S)"
              sudo cp "$NGINX_CONFIG_FILE" "$BACKUP_FILE" || true
              echo "‚úÖ Backup created: $BACKUP_FILE"
            fi
            
            # Copy config with sudo
            echo "Copying nginx config to $NGINX_CONFIG_FILE..."
            sudo cp "$TEMP_CONFIG" "$NGINX_CONFIG_FILE"
            sudo chmod 644 "$NGINX_CONFIG_FILE"
            
            # Update root directory in config based on actual deployment structure
            # Try multiple path patterns to ensure we catch all variations
            echo "Determining frontend root directory..."
            FRONTEND_ROOT=""
            
            # Priority 1: Check for build/dist/client (Vite output structure)
            if [ -f "$FRONTEND_TARGET/build/dist/client/index.html" ]; then
              FRONTEND_ROOT="$FRONTEND_TARGET/build/dist/client"
              echo "‚úÖ Found build/dist/client: $FRONTEND_ROOT"
            # Priority 2: Check for current/dist/client
            elif [ -f "$FRONTEND_TARGET/current/dist/client/index.html" ]; then
              FRONTEND_ROOT="$FRONTEND_TARGET/current/dist/client"
              echo "‚úÖ Found current/dist/client: $FRONTEND_ROOT"
            # Priority 3: Check for build symlink with dist/client inside
            elif [ -L "$FRONTEND_TARGET/build" ] || [ -d "$FRONTEND_TARGET/build" ]; then
              BUILD_PATH=$(readlink -f "$FRONTEND_TARGET/build" 2>/dev/null || echo "$FRONTEND_TARGET/build")
              if [ -f "$BUILD_PATH/dist/client/index.html" ]; then
                FRONTEND_ROOT="$BUILD_PATH/dist/client"
                echo "‚úÖ Found build symlink -> dist/client: $FRONTEND_ROOT"
              elif [ -f "$BUILD_PATH/index.html" ]; then
                FRONTEND_ROOT="$BUILD_PATH"
                echo "‚úÖ Found build directory with index.html: $FRONTEND_ROOT"
              else
                FRONTEND_ROOT="$FRONTEND_TARGET/build"
                echo "‚úÖ Found build directory/symlink: $FRONTEND_ROOT"
              fi
            # Priority 4: Check for current symlink
            elif [ -L "$FRONTEND_TARGET/current" ] || [ -d "$FRONTEND_TARGET/current" ]; then
              CURRENT_PATH=$(readlink -f "$FRONTEND_TARGET/current" 2>/dev/null || echo "$FRONTEND_TARGET/current")
              if [ -f "$CURRENT_PATH/dist/client/index.html" ]; then
                FRONTEND_ROOT="$CURRENT_PATH/dist/client"
                echo "‚úÖ Found current symlink -> dist/client: $FRONTEND_ROOT"
              else
                FRONTEND_ROOT="$CURRENT_PATH"
                echo "‚úÖ Found current symlink: $FRONTEND_ROOT"
              fi
            # Priority 5: Check for dist/client (direct build output)
            elif [ -d "$FRONTEND_TARGET/../dist/client" ]; then
              FRONTEND_ROOT="$(dirname $FRONTEND_TARGET)/dist/client"
              echo "‚úÖ Found dist/client: $FRONTEND_ROOT"
            # Priority 6: Check if TARGET_DIR itself contains the build
            elif [ -f "$FRONTEND_TARGET/index.html" ]; then
              FRONTEND_ROOT="$FRONTEND_TARGET"
              echo "‚úÖ Found index.html directly in TARGET_DIR: $FRONTEND_ROOT"
            else
              echo "‚ö†Ô∏è  Warning: Could not determine frontend directory structure"
              echo "   TARGET_DIR: $FRONTEND_TARGET"
              echo "   Available paths:"
              ls -la "$FRONTEND_TARGET" 2>/dev/null || true
              ls -la "$FRONTEND_TARGET/build" 2>/dev/null || true
              ls -la "$(dirname $FRONTEND_TARGET)" 2>/dev/null || true
              # Use build/dist/client as default (Vite output structure)
              FRONTEND_ROOT="$FRONTEND_TARGET/build/dist/client"
              echo "   Using default: $FRONTEND_ROOT"
            fi
            
            # Update nginx config with determined path
            if [ ! -z "$FRONTEND_ROOT" ]; then
              echo "Updating nginx root to: $FRONTEND_ROOT"
              # Update all possible path patterns in config (including dist/client variations)
              sudo sed -i "s|root /var/www/christina-sings4you/dist/client|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/build/dist/client|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/build|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/current|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/current/dist/client|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              # Also update the ACME challenge location
              sudo sed -i "s|root /var/www/html|root /var/www/html|g" "$NGINX_CONFIG_FILE" || true
              # Verify the update
              UPDATED_ROOT=$(grep -E "^\s*root\s+" "$NGINX_CONFIG_FILE" | head -1 | sed 's/.*root\s\+\([^;]*\);.*/\1/')
              echo "‚úÖ Nginx root updated to: $UPDATED_ROOT"
            fi
            
            # Ensure backend port is correct (4000)
            echo "Ensuring backend port is 4000..."
            sudo sed -i "s|proxy_pass http://localhost:3001|proxy_pass http://localhost:4000|g" "$NGINX_CONFIG_FILE"
            
            # Create symlink if not exists
            if [ ! -L "${NGINX_SITES_ENABLED}/${DOMAIN}.conf" ]; then
              echo "Creating symlink in sites-enabled..."
              sudo ln -s "$NGINX_CONFIG_FILE" "${NGINX_SITES_ENABLED}/${DOMAIN}.conf"
            fi
            
            # Remove default site if exists
            if [ -L "${NGINX_SITES_ENABLED}/default" ]; then
              echo "Removing default nginx site..."
              sudo rm "${NGINX_SITES_ENABLED}/default"
            fi
            
            # Test nginx configuration
            echo "Testing nginx configuration..."
            if sudo nginx -t; then
              echo "‚úÖ Nginx configuration is valid"
            else
              echo "‚ùå ERROR: Nginx configuration test failed!"
              sudo nginx -t
              exit 1
            fi
            
            # Reload nginx
            echo "Reloading nginx..."
            sudo systemctl reload nginx || sudo systemctl restart nginx
            echo "‚úÖ Nginx reloaded successfully"
            
            # Cleanup temp file
            rm -f "$TEMP_CONFIG"
            
            echo "‚úÖ Nginx configuration deployed"

      # ‚úÖ Upload Deployment Scripts
      - name: Upload deployment scripts
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "deployment/scripts/start-pm2.sh,deployment/scripts/check-deployment.sh"
          target: "${{ secrets.BACKEND_TARGET_DIR }}/deployment/scripts"
          overwrite: true

      - name: Make scripts executable
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 30s
          command_timeout: 1m
          use_insecure_cipher: false
          script: |
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            chmod +x "$BACKEND_TARGET/deployment/scripts/start-pm2.sh"
            chmod +x "$BACKEND_TARGET/deployment/scripts/check-deployment.sh"
            echo "‚úÖ Scripts are now executable"

      # ‚úÖ Run Diagnostic Check
      - name: Run deployment diagnostic
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set +e  # Don't exit on error for diagnostic
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            cd "$BACKEND_TARGET"
            echo "=== Running Deployment Diagnostic ==="
            bash "$BACKEND_TARGET/deployment/scripts/check-deployment.sh" || {
              echo "‚ö†Ô∏è Diagnostic script encountered issues, but continuing..."
            }

      # ‚úÖ Ensure PM2 is Running
      - name: Ensure PM2 is running
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            cd "$BACKEND_TARGET"
            echo "=== Ensuring PM2 is Running ==="
            
            # Check if PM2 process is running
            if pm2 list | grep -q "sing4you-api.*online"; then
              echo "‚úÖ PM2 process 'sing4you-api' is already running"
              pm2 list
            else
              echo "‚ö†Ô∏è PM2 process 'sing4you-api' is not running"
              echo "Attempting to start PM2..."
              
              # Try to start using the script
              if [ -f "$BACKEND_TARGET/deployment/scripts/start-pm2.sh" ]; then
                bash "$BACKEND_TARGET/deployment/scripts/start-pm2.sh" || {
                  echo "‚ö†Ô∏è Script start failed, trying manual start..."
                  
                  # Manual start fallback
                  cd "$BACKEND_TARGET"
                  
                  # Check if dist exists
                  if [ ! -f "dist/server/index.js" ]; then
                    echo "‚ùå ERROR: dist/server/index.js not found!"
                    echo "Available files:"
                    ls -la dist/ 2>/dev/null || echo "dist directory does not exist"
                    exit 1
                  fi
                  
                  # Install dependencies if needed
                  if [ ! -d "node_modules" ]; then
                    echo "Installing dependencies..."
                    npm install --production
                  fi
                  
                  # Stop old process
                  pm2 stop sing4you-api || true
                  pm2 delete sing4you-api || true
                  
                  # Start PM2
                  mkdir -p logs
                  # Use ecosystem.config.cjs if available, otherwise start directly
                  if [ -f "ecosystem.config.cjs" ]; then
                    pm2 start ecosystem.config.cjs
                  else
                    pm2 start dist/server/index.js \
                      --name sing4you-api \
                      --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                      --merge-logs \
                      --error ./logs/pm2-error.log \
                      --output ./logs/pm2-out.log
                  fi
                  
                  pm2 save
                }
              else
                echo "‚ùå start-pm2.sh script not found!"
                exit 1
              fi
              
              # Verify it started
              sleep 3
              if pm2 list | grep -q "sing4you-api.*online"; then
                echo "‚úÖ PM2 process started successfully"
              else
                echo "‚ùå ERROR: PM2 process failed to start"
                pm2 list
                pm2 logs sing4you-api --lines 30 --nostream || true
                exit 1
              fi
            fi

      # ‚úÖ Verify Deployment
      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          script: |
            set -e
            echo "=== Verification ==="

            # Check PM2 status
            echo "PM2 Status:"
            pm2 status || true
            pm2 logs sing4you-api --lines 20 --nostream || true

            # Check backend health
            echo -e "\nBackend Health Check:"
            sleep 3
            curl -f http://localhost:4000/api/health || echo "‚ö†Ô∏è Health check failed (may need more time)"

            # Check frontend
            echo -e "\nFrontend Check:"
            if [ -L "${{ secrets.TARGET_DIR }}/current" ]; then
              echo "‚úÖ Frontend symlink exists"
              ls -la "${{ secrets.TARGET_DIR }}/current" | head -5
            else
              echo "‚ö†Ô∏è Frontend symlink not found"
            fi

            echo -e "\n‚úÖ Deployment verification complete"
