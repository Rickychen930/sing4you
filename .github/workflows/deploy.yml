name: Deploy Full Stack App to VPS

on:
  push:
    branches: [main, master]
  workflow_dispatch:  # Allow manual trigger from GitHub Actions UI

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Setup SSH
        run: |
          # ============================================================================
          # SSH Configuration
          # ============================================================================
          # Required GitHub Secrets:
          # - SERVER_HOST: IP address (e.g., 76.13.96.198)
          # - SERVER_USER: SSH username (e.g., root)
          # - SSH_PORT: SSH port (e.g., 22)
          # - SSH_PRIVATE_KEY: Complete private key including BEGIN/END lines
          # - TARGET_DIR: Frontend deployment directory
          # - BACKEND_TARGET_DIR: Backend deployment directory
          # ============================================================================
          
          # Validate required secrets
          if [ -z "${{ secrets.TARGET_DIR }}" ]; then
            echo "‚ùå ERROR: TARGET_DIR secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.BACKEND_TARGET_DIR }}" ]; then
            echo "‚ùå ERROR: BACKEND_TARGET_DIR secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå ERROR: SSH_PRIVATE_KEY secret is not set!"
            exit 1
          fi
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå ERROR: SERVER_HOST secret is not set!"
            echo "   Expected: 76.13.96.198"
            exit 1
          fi
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            echo "‚ùå ERROR: SERVER_USER secret is not set!"
            echo "   Expected: root"
            exit 1
          fi
          if [ -z "${{ secrets.SSH_PORT }}" ]; then
            echo "‚ùå ERROR: SSH_PORT secret is not set!"
            echo "   Expected: 22 (or your SSH port)"
            exit 1
          fi
          
          echo "üîß Setting up SSH..."
          echo "Host: ${{ secrets.SERVER_HOST }}"
          echo "User: ${{ secrets.SERVER_USER }}"
          echo "Port: ${{ secrets.SSH_PORT }}"
          echo ""
          echo "üìù Note: SSH connection will be: ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}"
          
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Write SSH key with proper formatting
          # Store secret in variable first to preserve all newlines
          SSH_KEY="${{ secrets.SSH_PRIVATE_KEY }}"
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Ensure file ends with newline (SSH requires this)
          if [ -s ~/.ssh/deploy_key ] && [ "$(tail -c 1 ~/.ssh/deploy_key | wc -l)" -eq 0 ]; then
            echo "" >> ~/.ssh/deploy_key
          fi
          
          # Verify key format and structure
          echo "üîç Verifying SSH key format..."
          KEY_FILE=~/.ssh/deploy_key
          
          if [ ! -f "$KEY_FILE" ]; then
            echo "‚ùå ERROR: SSH key file was not created!"
            exit 1
          fi
          
          # Check for BEGIN marker
          if ! grep -q "BEGIN.*PRIVATE KEY" "$KEY_FILE"; then
            echo "‚ùå ERROR: SSH key is missing BEGIN marker!"
            echo "First 100 chars: $(head -c 100 "$KEY_FILE")"
            exit 1
          fi
          
          # Check for END marker
          if ! grep -q "END.*PRIVATE KEY" "$KEY_FILE"; then
            echo "‚ùå ERROR: SSH key is missing END marker!"
            echo "Last 100 chars: $(tail -c 100 "$KEY_FILE")"
            exit 1
          fi
          
          # Check key file size (should be reasonable, not empty or too small)
          KEY_SIZE=$(wc -c < "$KEY_FILE")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå ERROR: SSH key file is too small ($KEY_SIZE bytes). Key may be corrupted!"
            exit 1
          fi
          
          # Validate key format with ssh-keygen
          if ssh-keygen -l -f "$KEY_FILE" > /dev/null 2>&1; then
            echo "‚úÖ SSH key format is valid"
            ssh-keygen -l -f "$KEY_FILE"
          else
            echo "‚ö†Ô∏è  WARNING: ssh-keygen validation failed, but continuing..."
            echo "Key may need passphrase or may be in different format"
          fi
          
          # Add server to known_hosts
          echo "üîë Adding server to known_hosts..."
          ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts
          
          # Setup SSH agent and add key
          echo "üîê Setting up SSH agent..."
          eval $(ssh-agent -s)
          ssh-add ~/.ssh/deploy_key 2>&1 || {
            echo "‚ö†Ô∏è  WARNING: Failed to add key to ssh-agent (may need passphrase)"
          }
          
          echo "‚úÖ SSH key configured"
          
          # Verify key file exists and has correct permissions
          if [ ! -f ~/.ssh/deploy_key ]; then
            echo "‚ùå ERROR: SSH key file not found at ~/.ssh/deploy_key"
            exit 1
          fi
          
          # Show key fingerprint for debugging
          echo "üîë SSH Key Fingerprint:"
          ssh-keygen -l -f ~/.ssh/deploy_key 2>&1 || echo "‚ö†Ô∏è  Could not get fingerprint"
          
          # Extract and show public key (for troubleshooting)
          echo ""
          echo "üìã Public Key (to add to server's ~/.ssh/authorized_keys if needed):"
          ssh-keygen -y -f ~/.ssh/deploy_key 2>&1 | head -1 || echo "‚ö†Ô∏è  Could not extract public key"
          echo ""
          
          # Test basic connectivity first
          echo "üåê Testing basic connectivity..."
          echo "Host: ${{ secrets.SERVER_HOST }}"
          echo "Port: ${{ secrets.SSH_PORT }}"
          echo "User: ${{ secrets.SERVER_USER }}"
          echo ""
          
          # Test if host is reachable (ping-like test with timeout)
          if command -v nc >/dev/null 2>&1; then
            echo "Testing port connectivity with nc..."
            if nc -zv -w 5 ${{ secrets.SERVER_HOST }} ${{ secrets.SSH_PORT }} 2>&1; then
              echo "‚úÖ Port ${{ secrets.SSH_PORT }} is reachable"
            else
              echo "‚ùå Port ${{ secrets.SSH_PORT }} is NOT reachable"
              echo "‚ö†Ô∏è  This might be a firewall/network issue"
            fi
          fi
          
          echo ""
          echo "üß™ Testing SSH connection..."
          
          # Test connection with detailed output
          ssh -v -i ~/.ssh/deploy_key \
              -o StrictHostKeyChecking=no \
              -o IdentitiesOnly=yes \
              -o ConnectTimeout=15 \
              -o PasswordAuthentication=no \
              -o BatchMode=yes \
              -p ${{ secrets.SSH_PORT }} \
              ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
              "echo '‚úÖ SSH connection successful'" 2>&1 || {
            echo ""
            echo "‚ùå SSH connection test failed!"
            echo ""
            echo "üîç Diagnostic Information:"
            echo "  Host: ${{ secrets.SERVER_HOST }}"
            echo "  Port: ${{ secrets.SSH_PORT }}"
            echo "  User: ${{ secrets.SERVER_USER }}"
            echo ""
            echo "üìã Troubleshooting steps:"
            echo ""
            echo "1. CONNECTION TIMEOUT (if you see 'Connection timed out'):"
            echo "   ‚Üí Check if server IP is correct: ${{ secrets.SERVER_HOST }}"
            echo "   ‚Üí Check if SSH port is correct: ${{ secrets.SSH_PORT }}"
            echo "   ‚Üí Check firewall/security group allows port ${{ secrets.SSH_PORT }} from GitHub Actions"
            echo "   ‚Üí GitHub Actions IP ranges: 140.82.112.0/20, 143.55.64.0/20"
            echo "   ‚Üí Test from your local: ssh -v ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} -p ${{ secrets.SSH_PORT }}"
            echo ""
            echo "2. AUTHENTICATION FAILED (if you see 'Permission denied'):"
            echo "   ‚Üí Verify public key is in ~/.ssh/authorized_keys on server"
            echo "   ‚Üí Check username: ${{ secrets.SERVER_USER }}"
            echo "   ‚Üí Verify SSH_PRIVATE_KEY format in GitHub Secrets (must include BEGIN/END lines)"
            echo ""
            echo "3. To add public key to server, run on server:"
            echo "   mkdir -p ~/.ssh && chmod 700 ~/.ssh"
            echo "   echo 'PUBLIC_KEY_HERE' >> ~/.ssh/authorized_keys"
            echo "   chmod 600 ~/.ssh/authorized_keys"
            echo ""
            echo "4. Check server firewall (on server):"
            echo "   sudo ufw status"
            echo "   sudo ufw allow ${{ secrets.SSH_PORT }}/tcp"
            echo ""
            exit 1
          }

      # ‚úÖ Build Frontend
      - name: Create .env.production for frontend
        run: |
          echo "REACT_APP_API_URL=${{ secrets.REACT_APP_API_URL }}" > .env.production

      - name: Build React app
        run: npm run build

      # ‚úÖ Create .env file for backend deployment (CRITICAL: Must include all env vars)
      - name: Create .env file for backend
        run: |
          echo "Creating .env file for backend deployment..."
          
          # Validate critical secrets before creating .env file
          echo "Validating GitHub Secrets..."
          MISSING_SECRETS=()
          
          if [ -z "${{ secrets.MONGODB_URI }}" ]; then
            MISSING_SECRETS+=("MONGODB_URI")
          fi
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_SECRET")
          fi
          if [ -z "${{ secrets.JWT_REFRESH_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_REFRESH_SECRET")
          fi
          
          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "‚ùå ERROR: The following required GitHub Secrets are not set:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "   - $secret"
            done
            echo ""
            echo "Please configure these secrets in GitHub Repository Settings > Secrets and variables > Actions"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are set"
          
          cat > .env.production << EOF
          # Server Configuration
          PORT=4000
          NODE_ENV=production
          CLIENT_URL=${{ secrets.CLIENT_URL }}
          SITE_URL=${{ secrets.SITE_URL }}
          
          # Database Configuration
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN || '1h' }}
          JWT_REFRESH_EXPIRES_IN=${{ secrets.JWT_REFRESH_EXPIRES_IN || '7d' }}
          
          # Cloudinary Configuration (Optional)
          CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          
          # Frontend Configuration
          VITE_API_URL=${{ secrets.VITE_API_URL }}
          VITE_SITE_URL=${{ secrets.VITE_SITE_URL }}
          
          # Email Configuration
          ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
          SMTP_SERVICE=${{ secrets.SMTP_SERVICE }}
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_SECURE=${{ secrets.SMTP_SECURE }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          
          # Site Configuration
          SITE_NAME=${{ secrets.SITE_NAME || 'Christina Sings4U' }}
          EOF
          echo "‚úÖ .env.production file created"
          
          # Verify critical variables are set and not empty
          if grep -q "^MONGODB_URI=" .env.production && ! grep -q "^MONGODB_URI=$" .env.production && ! grep -q "^MONGODB_URI=<" .env.production; then
            echo "‚úÖ MONGODB_URI is set"
          else
            echo "‚ùå ERROR: MONGODB_URI is missing or empty in .env.production!"
            echo "   Please check GitHub Secrets > MONGODB_URI"
            exit 1
          fi
          
          if grep -q "^JWT_SECRET=" .env.production && ! grep -q "^JWT_SECRET=$" .env.production; then
            echo "‚úÖ JWT_SECRET is set"
          else
            echo "‚ùå ERROR: JWT_SECRET is missing or empty in .env.production!"
            echo "   Please check GitHub Secrets > JWT_SECRET"
            exit 1
          fi

      # ‚úÖ Build Backend
      - name: Build backend server
        run: npm run build:server

      # ‚úÖ Prepare directories on VPS
      - name: Prepare VPS directories
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 10m
          use_insecure_cipher: false
          debug: true
          script: |
            set -e
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            RELEASES="$FRONTEND_TARGET/_releases"
            TS="$(date +%Y%m%d-%H%M%S)"
            NEW="$RELEASES/$TS"

            # Create parent directories first
            mkdir -p "$(dirname "$FRONTEND_TARGET")" 2>/dev/null || true
            mkdir -p "$(dirname "$BACKEND_TARGET")" 2>/dev/null || true
            
            # Frontend directories with explicit permissions
            echo "Creating frontend directories..."
            mkdir -p "$FRONTEND_TARGET"
            mkdir -p "$RELEASES"
            mkdir -p "$NEW"
            mkdir -p "$FRONTEND_TARGET/_incoming"
            chmod -R 755 "$FRONTEND_TARGET" || true
            chmod 777 "$FRONTEND_TARGET/_incoming" || true
            # Try to set ownership (may fail if not root, that's ok)
            chown -R "$(whoami):$(whoami)" "$FRONTEND_TARGET" 2>/dev/null || true

            # Backend directories with explicit permissions
            echo "Creating backend directories..."
            mkdir -p "$BACKEND_TARGET"
            mkdir -p "$BACKEND_TARGET/dist"
            mkdir -p "$BACKEND_TARGET/server"
            mkdir -p "$BACKEND_TARGET/_incoming_backend"
            chmod -R 755 "$BACKEND_TARGET" || true
            
            # Create SHARED uploads directory at project root (RECOMMENDED)
            # This is safer - never deleted during frontend/backend deployments
            PROJECT_ROOT="$(dirname $BACKEND_TARGET)"
            SHARED_UPLOADS_DIR="$PROJECT_ROOT/uploads"
            echo "Creating shared uploads directory at project root..."
            mkdir -p "$SHARED_UPLOADS_DIR"
            chmod 755 "$SHARED_UPLOADS_DIR" || chmod 777 "$SHARED_UPLOADS_DIR" || true
            chown -R "$(whoami):$(whoami)" "$SHARED_UPLOADS_DIR" 2>/dev/null || true
            echo "‚úÖ Shared uploads directory created: $SHARED_UPLOADS_DIR"
            # Uploads directory needs to be writable for file uploads
            chmod 755 "$BACKEND_TARGET/uploads" || true
            chmod 777 "$BACKEND_TARGET/_incoming_backend" || true
            # Try to set ownership (may fail if not root, that's ok)
            chown -R "$(whoami):$(whoami)" "$BACKEND_TARGET" 2>/dev/null || true
            # Ensure uploads directory is writable
            chmod 755 "$BACKEND_TARGET/uploads" || chmod 777 "$BACKEND_TARGET/uploads" || true
            echo "‚úÖ Uploads directory created at: $BACKEND_TARGET/uploads"

            # Verify directories are writable
            if [ ! -w "$FRONTEND_TARGET/_incoming" ]; then
              echo "‚ö†Ô∏è  Warning: $FRONTEND_TARGET/_incoming may not be writable"
              ls -ld "$FRONTEND_TARGET/_incoming" || true
            fi
            
            if [ ! -w "$BACKEND_TARGET/_incoming_backend" ]; then
              echo "‚ö†Ô∏è  Warning: $BACKEND_TARGET/_incoming_backend may not be writable"
              ls -ld "$BACKEND_TARGET/_incoming_backend" || true
            fi

            echo "‚úÖ Frontend release dir: $NEW"
            echo "‚úÖ Backend target: $BACKEND_TARGET"
            echo "‚úÖ All directories created"

      # ‚úÖ Upload Frontend build (using SCP like the working workflow)
      - name: Upload frontend build to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 20m
          use_insecure_cipher: false
          source: "dist/client/**"
          target: "${{ secrets.TARGET_DIR }}/_incoming"
          overwrite: true

      # ‚úÖ Ensure backend directories exist before upload
      - name: Ensure backend upload directories exist
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            
            if [ -z "$BACKEND_TARGET" ]; then
              echo "‚ùå ERROR: BACKEND_TARGET_DIR secret is not set!"
              echo "Please configure BACKEND_TARGET_DIR in GitHub Secrets"
              exit 1
            fi
            
            echo "Creating directories at: $BACKEND_TARGET"
            mkdir -p "$BACKEND_TARGET/_incoming_backend"
            mkdir -p "$BACKEND_TARGET"
            chmod -R 755 "$BACKEND_TARGET" || true
            echo "‚úÖ Backend directories ready"

      # ‚úÖ Upload Backend dist (using SCP like the working workflow)
      - name: Upload backend dist to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 20m
          use_insecure_cipher: false
          source: "dist/**"
          target: "${{ secrets.BACKEND_TARGET_DIR }}/_incoming_backend"
          overwrite: true

      # ‚úÖ Upload package.json and package-lock.json for dependency installation
      - name: Upload package files for dependency installation
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "package.json,package-lock.json"
          target: "${{ secrets.BACKEND_TARGET_DIR }}"
          overwrite: true

      # ‚úÖ Upload .env.production file to server (CRITICAL for database connection)
      - name: Upload .env.production file
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: ".env.production"
          target: "${{ secrets.BACKEND_TARGET_DIR }}"
          overwrite: true

      - name: Upload ecosystem.config.cjs via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            mkdir -p "$BACKEND_TARGET"
            # Determine PROJECT_ROOT for PM2 config (shared uploads location)
            PROJECT_ROOT_FOR_PM2="$(dirname $BACKEND_TARGET)"
            
            cat > "$BACKEND_TARGET/ecosystem.config.cjs" << EOF
            module.exports = {
              apps: [
                {
                  name: "sing4you-api",
                  script: "dist/server/index.js",
                  cwd: "${BACKEND_TARGET}",
                  instances: 1,
                  exec_mode: "fork",
                  env: {
                    NODE_ENV: "production",
                    PORT: 4000,
                    BACKEND_ROOT: "${BACKEND_TARGET}",
                    UPLOAD_DIR: "${PROJECT_ROOT_FOR_PM2}/uploads",
                  },
                  error_file: "./logs/pm2-error.log",
                  out_file: "./logs/pm2-out.log",
                  log_date_format: "YYYY-MM-DD HH:mm:ss Z",
                  merge_logs: true,
                  autorestart: true,
                  max_restarts: 10,
                  min_uptime: "10s",
                  max_memory_restart: "500M",
                  watch: false,
                  ignore_watch: ["node_modules", "logs", "uploads"],
                },
              ],
            };
            EOF
            chmod 644 "$BACKEND_TARGET/ecosystem.config.cjs"
            echo "‚úÖ ecosystem.config.cjs uploaded with cwd: ${BACKEND_TARGET}"

      # ‚úÖ Activate Frontend Release
      - name: Activate frontend release (atomic)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 10m
          use_insecure_cipher: false
          script: |
            set -e
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            RELEASES="$FRONTEND_TARGET/_releases"
            INCOMING="$FRONTEND_TARGET/_incoming"
            TS="$(date +%Y%m%d-%H%M%S)"
            NEW="$RELEASES/$TS"
            CURRENT="$FRONTEND_TARGET/current"
            BUILD_ROOT="$FRONTEND_TARGET/build"

            if [ ! -d "$INCOMING" ]; then
              echo "ERROR: Incoming frontend build not found at $INCOMING"
              ls -la "$FRONTEND_TARGET/_incoming" || true
              exit 1
            fi

            mkdir -p "$NEW"
            cp -a "$INCOMING"/. "$NEW"/
            
            # Note: Uploads are now in shared location at project root
            # No need to preserve from frontend build - they're separate

            # atomic switch
            rm -f "$CURRENT"
            ln -s "$NEW" "$CURRENT"

            # Keep nginx root in sync
            if [ -e "$BUILD_ROOT" ] || [ -L "$BUILD_ROOT" ]; then
              rm -rf "$BUILD_ROOT"
            fi
            ln -s "$NEW" "$BUILD_ROOT"
            
            # Note: Uploads are in shared location at project root, not in frontend build
            # Verify shared uploads directory exists (created in backend deployment step)

            chmod -R 755 "$NEW"
            rm -rf "$FRONTEND_TARGET/_incoming"
            
            # Uploads directory already created and preserved above, just verify
            if [ -d "$NEW/uploads" ]; then
              echo "‚úÖ Uploads directory verified: $NEW/uploads"
              ls -ld "$NEW/uploads"
            fi

            echo "‚úÖ Frontend activated"
            echo "Current -> $(readlink $CURRENT)"
            echo "BuildRoot -> $(readlink $BUILD_ROOT)"

      # ‚úÖ Deploy Backend
      - name: Deploy backend and restart PM2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 180s
          command_timeout: 15m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist"
            DIST_DIR="$BACKEND_TARGET/dist"

            # Handle different upload structures
            if [ -d "$BACKEND_TARGET/_incoming_backend/dist/dist" ]; then
              # If nested dist/dist structure
              INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist/dist"
            elif [ -d "$BACKEND_TARGET/_incoming_backend/dist" ]; then
              # Normal structure
              INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend/dist"
            else
              # Check if dist is directly in _incoming_backend
              if [ -d "$BACKEND_TARGET/_incoming_backend/server" ] || [ -f "$BACKEND_TARGET/_incoming_backend/server/server.js" ]; then
                INCOMING_BACKEND="$BACKEND_TARGET/_incoming_backend"
              fi
            fi
            ENV_FILE="$BACKEND_TARGET/server/.env"
            ENV_PROD_FILE="$BACKEND_TARGET/.env.production"

            echo "=== Backend Deployment ==="

            # Check if incoming backend exists
            if [ ! -d "$INCOMING_BACKEND" ]; then
              echo "ERROR: Incoming backend dist not found at $INCOMING_BACKEND"
              ls -la "$BACKEND_TARGET/_incoming_backend" || true
              exit 1
            fi

            # Backup current dist (optional, for rollback)
            if [ -d "$DIST_DIR" ]; then
              echo "Backing up current dist..."
              BACKUP_DIR="$BACKEND_TARGET/dist.backup.$(date +%Y%m%d-%H%M%S)"
              cp -a "$DIST_DIR" "$BACKUP_DIR" || true
              echo "Backup created at: $BACKUP_DIR"
            fi

            # Remove old dist and copy new one
            echo "Deploying new backend dist..."
            rm -rf "$DIST_DIR"
            mkdir -p "$DIST_DIR"
            cp -a "$INCOMING_BACKEND"/. "$DIST_DIR"/
            
            # Ensure SHARED uploads directory exists and is writable (at project root)
            # This directory is NEVER deleted during deployments
            PROJECT_ROOT="$(dirname $BACKEND_TARGET)"
            SHARED_UPLOADS_DIR="$PROJECT_ROOT/uploads"
            echo "Ensuring shared uploads directory exists at project root..."
            mkdir -p "$SHARED_UPLOADS_DIR"
            chmod 755 "$SHARED_UPLOADS_DIR" || chmod 777 "$SHARED_UPLOADS_DIR" || true
            # Try to set ownership for uploads directory
            chown -R "$(whoami):$(whoami)" "$SHARED_UPLOADS_DIR" 2>/dev/null || true
            echo "‚úÖ Shared uploads directory verified: $SHARED_UPLOADS_DIR"
            ls -ld "$SHARED_UPLOADS_DIR" || true
            # List files to verify
            echo "Files in shared uploads directory:"
            ls -la "$SHARED_UPLOADS_DIR" | head -10 || echo "Directory is empty"

            # CRITICAL: Ensure .env file exists with all environment variables
            # Priority: Use uploaded .env.production (created from GitHub Secrets)
            if [ -f "$ENV_PROD_FILE" ]; then
              echo "‚úÖ Found .env.production file, copying to root .env..."
              cp "$ENV_PROD_FILE" "$BACKEND_TARGET/.env"
              echo "‚úÖ .env file created from .env.production"
            elif [ -f "$ENV_FILE" ]; then
              echo "Copying server/.env to root .env for production..."
              cp "$ENV_FILE" "$BACKEND_TARGET/.env"
            else
              echo "‚ùå ERROR: No .env file found!"
              echo "   Expected: $ENV_PROD_FILE or $ENV_FILE"
              echo "   Available files in $BACKEND_TARGET:"
              ls -la "$BACKEND_TARGET" | grep -E "\.env|env" || echo "   No .env files found"
              exit 1
            fi
            
            # Verify .env file has critical variables
            if [ -f "$BACKEND_TARGET/.env" ]; then
              echo "Verifying .env file contents..."
              echo "üìÑ .env file location: $BACKEND_TARGET/.env"
              echo "üìÑ File size: $(wc -c < "$BACKEND_TARGET/.env") bytes"
              
              # Check for critical variables
              MONGODB_URI_VALUE=$(grep "^MONGODB_URI=" "$BACKEND_TARGET/.env" | cut -d'=' -f2- | tr -d ' ')
              if [ -z "$MONGODB_URI_VALUE" ]; then
                echo "‚ùå ERROR: MONGODB_URI is missing or empty in .env file!"
                echo ""
                echo "   This usually means GitHub Secrets are not configured properly."
                echo "   Please check:"
                echo "   1. Go to GitHub Repository > Settings > Secrets and variables > Actions"
                echo "   2. Ensure MONGODB_URI secret is set with your MongoDB connection string"
                echo "   3. Format: mongodb+srv://username:password@cluster.mongodb.net/database"
                echo ""
                echo "   Current .env file contents (first 15 lines):"
                head -15 "$BACKEND_TARGET/.env" || echo "   Could not read .env file"
                echo ""
                echo "   Available files in $BACKEND_TARGET:"
                ls -la "$BACKEND_TARGET" | grep -E "\.env" || echo "   No .env files found"
                exit 1
              elif echo "$MONGODB_URI_VALUE" | grep -q "<db_password>"; then
                echo "‚ùå ERROR: MONGODB_URI contains placeholder '<db_password>'!"
                echo "   Please update GitHub Secrets > MONGODB_URI with actual database password"
                exit 1
              else
                echo "‚úÖ MONGODB_URI is set in .env"
                # Show first few chars (without exposing full connection string)
                MONGODB_PREVIEW=$(grep "^MONGODB_URI=" "$BACKEND_TARGET/.env" | cut -c1-30)
                echo "   Preview: ${MONGODB_PREVIEW}..."
              fi
              
              if grep -q "^NODE_ENV=production" "$BACKEND_TARGET/.env"; then
                echo "‚úÖ NODE_ENV is set to production"
              else
                echo "‚ö†Ô∏è  WARNING: NODE_ENV may not be set to production"
                # Try to fix it
                if ! grep -q "^NODE_ENV=" "$BACKEND_TARGET/.env"; then
                  echo "   Adding NODE_ENV=production to .env"
                  echo "NODE_ENV=production" >> "$BACKEND_TARGET/.env"
                fi
              fi
              
              # Verify other critical variables
              if grep -q "^JWT_SECRET=" "$BACKEND_TARGET/.env" && ! grep -q "^JWT_SECRET=$" "$BACKEND_TARGET/.env"; then
                echo "‚úÖ JWT_SECRET is set"
              else
                echo "‚ö†Ô∏è  WARNING: JWT_SECRET may not be set"
              fi
              
              # Show summary of .env file (without sensitive data)
              echo ""
              echo "üìã .env file summary (non-sensitive variables):"
              grep -E "^(PORT|NODE_ENV|CLIENT_URL|SITE_URL|VITE_)=" "$BACKEND_TARGET/.env" || echo "   Some variables not found"
              echo ""
            else
              echo "‚ùå ERROR: .env file was not created!"
              echo "   Expected location: $BACKEND_TARGET/.env"
              echo "   Available files in $BACKEND_TARGET:"
              ls -la "$BACKEND_TARGET" | head -20 || echo "   Could not list directory"
              exit 1
            fi
            
            # Ensure PORT=4000 in .env (critical for nginx proxy)
            if [ -f "$BACKEND_TARGET/.env" ]; then
              echo "Ensuring PORT=4000 in .env..."
              if grep -q "^PORT=" "$BACKEND_TARGET/.env"; then
                sed -i 's/^PORT=.*/PORT=4000/' "$BACKEND_TARGET/.env"
              else
                echo "PORT=4000" >> "$BACKEND_TARGET/.env"
              fi
              echo "‚úÖ PORT set to 4000 in .env"
            fi

            # Verify critical files
            if [ ! -f "$DIST_DIR/server/index.js" ]; then
              echo "ERROR: index.js not found in dist!"
              exit 1
            fi

            echo "‚úÖ Backend files deployed"

            # Install dependencies if package.json exists
            echo "=== Installing Dependencies ==="
            if [ -f "$BACKEND_TARGET/package.json" ]; then
              echo "package.json found, installing dependencies..."
              cd "$BACKEND_TARGET"
              npm install --production
              if [ $? -eq 0 ]; then
                echo "‚úÖ Dependencies installed successfully"
              else
                echo "‚ö†Ô∏è  Warning: npm install failed, but continuing..."
              fi
            else
              echo "‚ö†Ô∏è  Warning: package.json not found, skipping dependency installation"
              echo "‚ö†Ô∏è  You may need to install dependencies manually"
            fi

            # Stop old PM2 process if running
            echo "=== PM2 Management ==="
            pm2 stop sing4you-api || true
            pm2 delete sing4you-api || true

            # Kill any process on port 4000 (safety measure)
            echo "Checking for processes on port 4000..."
            PORT_PID=$(lsof -ti:4000 || true)
            if [ ! -z "$PORT_PID" ]; then
              echo "Killing process $PORT_PID on port 4000..."
              kill -9 $PORT_PID || true
              sleep 2
            fi

            # Start PM2 with proper environment
            echo "Starting PM2 process..."
            cd "$BACKEND_TARGET"

            # Verify dist/server/index.js exists
            if [ ! -f "dist/server/index.js" ]; then
              echo "‚ùå ERROR: dist/server/index.js not found!"
              echo "Available files in dist/server:"
              ls -la dist/server/ || echo "dist/server directory does not exist"
              exit 1
            fi

            # Check if node_modules exists, if not, install dependencies
            if [ ! -d "node_modules" ]; then
              echo "‚ö†Ô∏è  node_modules not found, installing dependencies..."
              npm install --production || {
                echo "‚ùå ERROR: npm install failed!"
                exit 1
              }
            fi

            # Use ecosystem.config.cjs if exists, otherwise start directly
            if [ -f "ecosystem.config.cjs" ]; then
              echo "Using ecosystem.config.cjs..."
              pm2 start ecosystem.config.cjs || {
                echo "‚ùå ERROR: Failed to start PM2 with ecosystem.config.cjs"
                echo "Trying direct start..."
                mkdir -p logs
                pm2 start dist/server/index.js \
                  --name sing4you-api \
                  --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                  --merge-logs \
                  --error ./logs/pm2-error.log \
                  --output ./logs/pm2-out.log
              }
            else
              echo "‚ö†Ô∏è  ecosystem.config.cjs not found, starting directly..."
              echo "   Make sure .env file exists in root directory"
              mkdir -p logs
              pm2 start dist/server/index.js \
                --name sing4you-api \
                --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                --merge-logs \
                --error ./logs/pm2-error.log \
                --output ./logs/pm2-out.log
            fi

            # Wait a moment and check if PM2 process started successfully
            sleep 3
            if pm2 list | grep -q "sing4you-api.*online"; then
              echo "‚úÖ PM2 process started successfully"
            else
              echo "‚ö†Ô∏è  WARNING: PM2 process may not have started correctly"
              echo "PM2 status:"
              pm2 list
              echo "PM2 logs:"
              pm2 logs sing4you-api --lines 20 --nostream || true
            fi

            # Save PM2 configuration
            pm2 save

            # Cleanup incoming backend
            rm -rf "$BACKEND_TARGET/_incoming_backend"
            
            # Final verification: Ensure uploads directory exists and is writable
            echo "=== Final Uploads Directory Verification ==="
            if [ -d "$BACKEND_TARGET/uploads" ]; then
              echo "‚úÖ Uploads directory exists: $BACKEND_TARGET/uploads"
              ls -ld "$BACKEND_TARGET/uploads"
              # Ensure it's writable
              chmod 755 "$BACKEND_TARGET/uploads" || chmod 777 "$BACKEND_TARGET/uploads" || true
              # Test write permission
              if touch "$BACKEND_TARGET/uploads/.write_test" 2>/dev/null; then
                rm -f "$BACKEND_TARGET/uploads/.write_test"
                echo "‚úÖ Uploads directory is writable"
              else
                echo "‚ö†Ô∏è  WARNING: Uploads directory may not be writable"
                echo "   Attempting to fix permissions..."
                chmod 777 "$BACKEND_TARGET/uploads" || true
                chown -R "$(whoami):$(whoami)" "$BACKEND_TARGET/uploads" 2>/dev/null || true
              fi
            else
              echo "‚ö†Ô∏è  WARNING: Uploads directory does not exist, creating..."
              mkdir -p "$BACKEND_TARGET/uploads"
              chmod 755 "$BACKEND_TARGET/uploads" || chmod 777 "$BACKEND_TARGET/uploads" || true
              chown -R "$(whoami):$(whoami)" "$BACKEND_TARGET/uploads" 2>/dev/null || true
              echo "‚úÖ Uploads directory created"
            fi

            echo "‚úÖ Backend deployment complete"

      # ‚úÖ Deploy Nginx Configuration
      - name: Upload nginx configuration
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "deployment/nginx/christina-sings4you.com.au.conf"
          target: "/tmp"
          overwrite: true

      - name: Deploy nginx configuration to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            DOMAIN="christina-sings4you.com.au"
            NGINX_SITES_AVAILABLE="/etc/nginx/sites-available"
            NGINX_SITES_ENABLED="/etc/nginx/sites-enabled"
            NGINX_CONFIG_FILE="${NGINX_SITES_AVAILABLE}/${DOMAIN}.conf"
            TEMP_CONFIG="/tmp/christina-sings4you.com.au.conf"
            FRONTEND_TARGET="${{ secrets.TARGET_DIR }}"
            
            echo "=== Nginx Configuration Deployment ==="
            
            # Debug: Check what files are in /tmp
            echo "Checking /tmp directory for uploaded files..."
            ls -la /tmp/ | grep -i "christina\|nginx" || true
            find /tmp -name "*christina*" -o -name "*nginx*" 2>/dev/null || true
            
            # Check if temp config exists in expected location
            if [ ! -f "$TEMP_CONFIG" ]; then
              echo "‚ö†Ô∏è  File not found at $TEMP_CONFIG, checking alternative locations..."
              # Check if it was uploaded with directory structure preserved
              if [ -f "/tmp/deployment/nginx/christina-sings4you.com.au.conf" ]; then
                echo "Found file at /tmp/deployment/nginx/christina-sings4you.com.au.conf, copying to expected location..."
                cp "/tmp/deployment/nginx/christina-sings4you.com.au.conf" "$TEMP_CONFIG"
              elif [ -f "/tmp/nginx/christina-sings4you.com.au.conf" ]; then
                echo "Found file at /tmp/nginx/christina-sings4you.com.au.conf, copying to expected location..."
                cp "/tmp/nginx/christina-sings4you.com.au.conf" "$TEMP_CONFIG"
              else
                echo "‚ùå ERROR: Nginx config file not found at $TEMP_CONFIG or alternative locations"
                echo "Contents of /tmp:"
                ls -la /tmp/ || true
                exit 1
              fi
            fi
            
            echo "‚úÖ Found nginx config file at $TEMP_CONFIG"
            
            # Backup existing config if exists
            if [ -f "$NGINX_CONFIG_FILE" ]; then
              echo "Backing up existing nginx config..."
              BACKUP_FILE="${NGINX_CONFIG_FILE}.backup.$(date +%Y%m%d-%H%M%S)"
              sudo cp "$NGINX_CONFIG_FILE" "$BACKUP_FILE" || true
              echo "‚úÖ Backup created: $BACKUP_FILE"
            fi
            
            # Copy config with sudo
            echo "Copying nginx config to $NGINX_CONFIG_FILE..."
            sudo cp "$TEMP_CONFIG" "$NGINX_CONFIG_FILE"
            sudo chmod 644 "$NGINX_CONFIG_FILE"
            
            # Update root directory in config based on actual deployment structure
            # Try multiple path patterns to ensure we catch all variations
            echo "Determining frontend root directory..."
            FRONTEND_ROOT=""
            
            # Priority 1: Check for build/dist/client (Vite output structure)
            if [ -f "$FRONTEND_TARGET/build/dist/client/index.html" ]; then
              FRONTEND_ROOT="$FRONTEND_TARGET/build/dist/client"
              echo "‚úÖ Found build/dist/client: $FRONTEND_ROOT"
            # Priority 2: Check for current/dist/client
            elif [ -f "$FRONTEND_TARGET/current/dist/client/index.html" ]; then
              FRONTEND_ROOT="$FRONTEND_TARGET/current/dist/client"
              echo "‚úÖ Found current/dist/client: $FRONTEND_ROOT"
            # Priority 3: Check for build symlink with dist/client inside
            elif [ -L "$FRONTEND_TARGET/build" ] || [ -d "$FRONTEND_TARGET/build" ]; then
              BUILD_PATH=$(readlink -f "$FRONTEND_TARGET/build" 2>/dev/null || echo "$FRONTEND_TARGET/build")
              if [ -f "$BUILD_PATH/dist/client/index.html" ]; then
                FRONTEND_ROOT="$BUILD_PATH/dist/client"
                echo "‚úÖ Found build symlink -> dist/client: $FRONTEND_ROOT"
              elif [ -f "$BUILD_PATH/index.html" ]; then
                FRONTEND_ROOT="$BUILD_PATH"
                echo "‚úÖ Found build directory with index.html: $FRONTEND_ROOT"
              else
                FRONTEND_ROOT="$FRONTEND_TARGET/build"
                echo "‚úÖ Found build directory/symlink: $FRONTEND_ROOT"
              fi
            # Priority 4: Check for current symlink
            elif [ -L "$FRONTEND_TARGET/current" ] || [ -d "$FRONTEND_TARGET/current" ]; then
              CURRENT_PATH=$(readlink -f "$FRONTEND_TARGET/current" 2>/dev/null || echo "$FRONTEND_TARGET/current")
              if [ -f "$CURRENT_PATH/dist/client/index.html" ]; then
                FRONTEND_ROOT="$CURRENT_PATH/dist/client"
                echo "‚úÖ Found current symlink -> dist/client: $FRONTEND_ROOT"
              else
                FRONTEND_ROOT="$CURRENT_PATH"
                echo "‚úÖ Found current symlink: $FRONTEND_ROOT"
              fi
            # Priority 5: Check for dist/client (direct build output)
            elif [ -d "$FRONTEND_TARGET/../dist/client" ]; then
              FRONTEND_ROOT="$(dirname $FRONTEND_TARGET)/dist/client"
              echo "‚úÖ Found dist/client: $FRONTEND_ROOT"
            # Priority 6: Check if TARGET_DIR itself contains the build
            elif [ -f "$FRONTEND_TARGET/index.html" ]; then
              FRONTEND_ROOT="$FRONTEND_TARGET"
              echo "‚úÖ Found index.html directly in TARGET_DIR: $FRONTEND_ROOT"
            else
              echo "‚ö†Ô∏è  Warning: Could not determine frontend directory structure"
              echo "   TARGET_DIR: $FRONTEND_TARGET"
              echo "   Available paths:"
              ls -la "$FRONTEND_TARGET" 2>/dev/null || true
              ls -la "$FRONTEND_TARGET/build" 2>/dev/null || true
              ls -la "$(dirname $FRONTEND_TARGET)" 2>/dev/null || true
              # Use build/dist/client as default (Vite output structure)
              FRONTEND_ROOT="$FRONTEND_TARGET/build/dist/client"
              echo "   Using default: $FRONTEND_ROOT"
            fi
            
            # Fix duplicate dist/client (causes redirect loop)
            FRONTEND_ROOT="${FRONTEND_ROOT//\/dist\/client\/dist\/client/\/dist\/client}"
            
            # Update nginx config with determined path
            if [ ! -z "$FRONTEND_ROOT" ]; then
              echo "Updating nginx root to: $FRONTEND_ROOT"
              # Update all possible path patterns in config (including dist/client variations)
              sudo sed -i "s|root /var/www/christina-sings4you/dist/client|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/build/dist/client|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/build|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/current|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you/frontend/current/dist/client|root $FRONTEND_ROOT|g" "$NGINX_CONFIG_FILE"
              sudo sed -i "s|root /var/www/christina-sings4you[^;]*;|root $FRONTEND_ROOT;|g" "$NGINX_CONFIG_FILE"
              # Fix any duplicate dist/client in root lines
              sudo sed -i 's|/dist/client/dist/client|/dist/client|g' "$NGINX_CONFIG_FILE"
              # Also update the ACME challenge location
              sudo sed -i "s|root /var/www/html|root /var/www/html|g" "$NGINX_CONFIG_FILE" || true
              # Verify the update
              UPDATED_ROOT=$(grep -E "^\s*root\s+" "$NGINX_CONFIG_FILE" | head -1 | sed 's/.*root\s\+\([^;]*\);.*/\1/')
              echo "‚úÖ Nginx root updated to: $UPDATED_ROOT"
            fi
            
            # Use 127.0.0.1:4000 (not localhost) to avoid IPv6 connection refused
            echo "Ensuring proxy_pass uses 127.0.0.1:4000..."
            sudo sed -i "s|proxy_pass http://localhost:3001|proxy_pass http://127.0.0.1:4000|g" "$NGINX_CONFIG_FILE"
            sudo sed -i "s|proxy_pass http://localhost:4000|proxy_pass http://127.0.0.1:4000|g" "$NGINX_CONFIG_FILE"
            
            # Update uploads directory path in nginx config
            # RECOMMENDED: Use shared uploads at project root (safest, never deleted)
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            PROJECT_ROOT="$(dirname $BACKEND_TARGET)"
            UPLOADS_DIR="$PROJECT_ROOT/uploads"
            echo "Updating nginx uploads directory to: $UPLOADS_DIR"
            echo "Project root: $PROJECT_ROOT"
            echo "Backend target: $BACKEND_TARGET"
            # Update root/alias path for /uploads location (try multiple patterns)
            # CRITICAL: Fix root path - must be PROJECT ROOT (parent of backend)
            # IMPORTANT: Only update root INSIDE location /uploads block, not the global root!
            EXPECTED_UPLOADS_ROOT="$PROJECT_ROOT"
            # CRITICAL: Ensure location /uploads uses prefix match ^~ to prevent global root override
            # First, ensure location uses prefix match
            sudo sed -i 's|^    location /uploads {|    location ^~ /uploads {|g' "$NGINX_CONFIG_FILE" || true
            # Use sed with range to only update root inside /uploads location block
            # This ensures we don't accidentally change the global frontend root
            # Match both "location /uploads" and "location ^~ /uploads" patterns
            sudo sed -i '/location \^~ \/uploads/,/^    }/ {
              s|root /var/www/christina-sings4you/frontend/build/dist/client;|root '"$EXPECTED_UPLOADS_ROOT"';|g
              s|root /var/www/christina-sings4you/frontend.*;|root '"$EXPECTED_UPLOADS_ROOT"';|g
              s|root /var/www/christina-sings4you;|root '"$EXPECTED_UPLOADS_ROOT"';|g
              s|root /var/www/christina-sings4you/backend;|root '"$EXPECTED_UPLOADS_ROOT"';|g
            }' "$NGINX_CONFIG_FILE" || true
            # Also match old pattern without ^~ (for backward compatibility)
            sudo sed -i '/location \/uploads/,/^    }/ {
              s|root /var/www/christina-sings4you/frontend/build/dist/client;|root '"$EXPECTED_UPLOADS_ROOT"';|g
              s|root /var/www/christina-sings4you/frontend.*;|root '"$EXPECTED_UPLOADS_ROOT"';|g
              s|root /var/www/christina-sings4you;|root '"$EXPECTED_UPLOADS_ROOT"';|g
              s|root /var/www/christina-sings4you/backend;|root '"$EXPECTED_UPLOADS_ROOT"';|g
            }' "$NGINX_CONFIG_FILE" || true
            # Remove alias if exists (we use root, not alias)
            # Match both patterns (with and without ^~)
            sudo sed -i '/location \^~ \/uploads/,/^    }/ {
              /^\s*alias /d
            }' "$NGINX_CONFIG_FILE" || true
            sudo sed -i '/location \/uploads/,/^    }/ {
              /^\s*alias /d
            }' "$NGINX_CONFIG_FILE" || true
            # Verify the update - check root (we use root, not alias)
            UPDATED_ROOT=$(grep -A 5 "location.*\/uploads" "$NGINX_CONFIG_FILE" | grep "root" | sed 's/.*root\s\+\([^;]*\);.*/\1/' || echo "not found")
            EXPECTED_ROOT="$PROJECT_ROOT"
            if [ "$UPDATED_ROOT" != "not found" ]; then
              echo "‚úÖ Nginx uploads root updated to: $UPDATED_ROOT"
              echo "   Expected root: $EXPECTED_ROOT"
              if [ "$UPDATED_ROOT" = "$EXPECTED_ROOT" ]; then
                echo "   ‚úÖ Root path is correct!"
              else
                echo "   ‚ö†Ô∏è  Root path mismatch (expected: $EXPECTED_ROOT, got: $UPDATED_ROOT)"
              fi
            else
              echo "‚ùå ERROR: Could not find root directive in location /uploads!"
              echo "   Please check nginx config manually"
            fi
            # Verify prefix match is used
            if grep -q "location ^~ /uploads" "$NGINX_CONFIG_FILE"; then
              echo "   ‚úÖ Prefix match ^~ is used"
            else
              echo "   ‚ö†Ô∏è  WARNING: Prefix match ^~ is NOT used!"
            fi
            echo "   üìÅ Uploads directory: $UPLOADS_DIR"
            # Verify directory exists
            if [ -d "$UPLOADS_DIR" ]; then
              echo "‚úÖ Uploads directory exists: $UPLOADS_DIR"
              ls -ld "$UPLOADS_DIR"
              # List some files to verify
              echo "Files in uploads directory:"
              ls -la "$UPLOADS_DIR" | head -10 || echo "Directory is empty or cannot list"
            else
              echo "‚ö†Ô∏è  WARNING: Uploads directory does not exist: $UPLOADS_DIR"
              echo "   Creating directory..."
              mkdir -p "$UPLOADS_DIR"
              chmod 755 "$UPLOADS_DIR" || chmod 777 "$UPLOADS_DIR" || true
              # Try to set ownership
              chown -R "$(whoami):$(whoami)" "$UPLOADS_DIR" 2>/dev/null || true
              echo "‚úÖ Uploads directory created"
            fi
            
            # Note: Uploads are now in shared location at project root
            # No need to create in frontend builds - they're separate and persistent
            
            # Test if nginx can access the directory
            echo "Testing nginx access to uploads directory..."
            if sudo test -r "$UPLOADS_DIR"; then
              echo "‚úÖ Nginx can read uploads directory"
            else
              echo "‚ö†Ô∏è  WARNING: Nginx may not be able to read uploads directory"
              echo "   Attempting to fix permissions..."
              sudo chmod 755 "$UPLOADS_DIR" || sudo chmod 777 "$UPLOADS_DIR" || true
            fi
            
            # Run fix-uploads script for additional verification
            if [ -f "$BACKEND_TARGET/deployment/scripts/fix-uploads.sh" ]; then
              echo "Running fix-uploads script..."
              BACKEND_ROOT="$BACKEND_TARGET" bash "$BACKEND_TARGET/deployment/scripts/fix-uploads.sh" || echo "‚ö†Ô∏è  Fix script encountered issues"
            fi
            
            # Create symlink if not exists
            if [ ! -L "${NGINX_SITES_ENABLED}/${DOMAIN}.conf" ]; then
              echo "Creating symlink in sites-enabled..."
              sudo ln -s "$NGINX_CONFIG_FILE" "${NGINX_SITES_ENABLED}/${DOMAIN}.conf"
            fi
            
            # Remove default site if exists
            if [ -L "${NGINX_SITES_ENABLED}/default" ]; then
              echo "Removing default nginx site..."
              sudo rm "${NGINX_SITES_ENABLED}/default"
            fi
            
            # Test nginx configuration
            echo "Testing nginx configuration..."
            if sudo nginx -t; then
              echo "‚úÖ Nginx configuration is valid"
            else
              echo "‚ùå ERROR: Nginx configuration test failed!"
              sudo nginx -t
              exit 1
            fi
            
            # CRITICAL: FULL RESTART nginx after updating uploads config
            # Reload is not enough - Nginx workers may still use old config
            # Full restart ensures all workers use the new config with prefix match ^~
            echo "FULL RESTART nginx to apply uploads configuration changes (prefix match ^~)..."
            echo "   This ensures location ^~ /uploads is processed correctly"
            sudo systemctl stop nginx 2>/dev/null || true
            sudo pkill -9 nginx 2>/dev/null || true
            sleep 2
            if sudo systemctl start nginx 2>/dev/null; then
              echo "‚úÖ Nginx FULL RESTART successful"
              echo "   üìÅ Uploads directory configured: $UPLOADS_DIR"
              echo "   ‚úÖ Location ^~ /uploads active with correct root"
            else
              echo "‚ùå ERROR: Failed to restart nginx"
              echo "   Please manually restart: sudo systemctl stop nginx && sudo pkill -9 nginx && sudo systemctl start nginx"
              echo "   üìÅ Uploads directory configured: $UPLOADS_DIR"
              exit 1
            fi
            
            # Cleanup temp file
            rm -f "$TEMP_CONFIG"
            
            echo "‚úÖ Nginx configuration deployed"

      # ‚úÖ Upload Deployment Scripts
      - name: Upload deployment scripts
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          source: "deployment/scripts/start-pm2.sh,deployment/scripts/check-deployment.sh,deployment/scripts/fix-uploads.sh"
          target: "${{ secrets.BACKEND_TARGET_DIR }}/deployment/scripts"
          overwrite: true

      - name: Make scripts executable
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 30s
          command_timeout: 1m
          use_insecure_cipher: false
          script: |
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            chmod +x "$BACKEND_TARGET/deployment/scripts/start-pm2.sh"
            chmod +x "$BACKEND_TARGET/deployment/scripts/check-deployment.sh"
            chmod +x "$BACKEND_TARGET/deployment/scripts/fix-uploads.sh"
            echo "‚úÖ Scripts are now executable"

      # ‚úÖ Run Diagnostic Check
      - name: Run deployment diagnostic
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set +e  # Don't exit on error for diagnostic
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            cd "$BACKEND_TARGET"
            echo "=== Running Deployment Diagnostic ==="
            bash "$BACKEND_TARGET/deployment/scripts/check-deployment.sh" || {
              echo "‚ö†Ô∏è Diagnostic script encountered issues, but continuing..."
            }

      # ‚úÖ Ensure PM2 is Running
      - name: Ensure PM2 is running
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 120s
          command_timeout: 5m
          use_insecure_cipher: false
          script: |
            set -e
            BACKEND_TARGET="${{ secrets.BACKEND_TARGET_DIR }}"
            cd "$BACKEND_TARGET"
            echo "=== Ensuring PM2 is Running ==="
            
            # Check if PM2 process is running
            if pm2 list | grep -q "sing4you-api.*online"; then
              echo "‚úÖ PM2 process 'sing4you-api' is already running"
              pm2 list
            else
              echo "‚ö†Ô∏è PM2 process 'sing4you-api' is not running"
              echo "Attempting to start PM2..."
              
              # Try to start using the script
              if [ -f "$BACKEND_TARGET/deployment/scripts/start-pm2.sh" ]; then
                bash "$BACKEND_TARGET/deployment/scripts/start-pm2.sh" || {
                  echo "‚ö†Ô∏è Script start failed, trying manual start..."
                  
                  # Manual start fallback
                  cd "$BACKEND_TARGET"
                  
                  # Check if dist exists
                  if [ ! -f "dist/server/index.js" ]; then
                    echo "‚ùå ERROR: dist/server/index.js not found!"
                    echo "Available files:"
                    ls -la dist/ 2>/dev/null || echo "dist directory does not exist"
                    exit 1
                  fi
                  
                  # Install dependencies if needed
                  if [ ! -d "node_modules" ]; then
                    echo "Installing dependencies..."
                    npm install --production
                  fi
                  
                  # Stop old process
                  pm2 stop sing4you-api || true
                  pm2 delete sing4you-api || true
                  
                  # Start PM2
                  mkdir -p logs
                  # Use ecosystem.config.cjs if available, otherwise start directly
                  if [ -f "ecosystem.config.cjs" ]; then
                    pm2 start ecosystem.config.cjs
                  else
                    pm2 start dist/server/index.js \
                      --name sing4you-api \
                      --log-date-format "YYYY-MM-DD HH:mm:ss Z" \
                      --merge-logs \
                      --error ./logs/pm2-error.log \
                      --output ./logs/pm2-out.log
                  fi
                  
                  pm2 save
                }
              else
                echo "‚ùå start-pm2.sh script not found!"
                exit 1
              fi
              
              # Verify it started
              sleep 3
              if pm2 list | grep -q "sing4you-api.*online"; then
                echo "‚úÖ PM2 process started successfully"
              else
                echo "‚ùå ERROR: PM2 process failed to start"
                pm2 list
                pm2 logs sing4you-api --lines 30 --nostream || true
                exit 1
              fi
            fi

      # ‚úÖ Verify Deployment
      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 2m
          use_insecure_cipher: false
          script: |
            set -e
            echo "=== Verification ==="

            # Check PM2 status
            echo "PM2 Status:"
            pm2 status || true
            pm2 logs sing4you-api --lines 20 --nostream || true

            # Check backend health
            echo -e "\nBackend Health Check:"
            sleep 3
            curl -f http://localhost:4000/api/health || echo "‚ö†Ô∏è Health check failed (may need more time)"

            # Check frontend
            echo -e "\nFrontend Check:"
            if [ -L "${{ secrets.TARGET_DIR }}/current" ]; then
              echo "‚úÖ Frontend symlink exists"
              ls -la "${{ secrets.TARGET_DIR }}/current" | head -5
            else
              echo "‚ö†Ô∏è Frontend symlink not found"
            fi

            echo -e "\n‚úÖ Deployment verification complete"
